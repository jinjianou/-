# 集群

集群调度架构 

[(3条消息) 十大主流集群调度系统大盘点_不正常IT研究所的博客-CSDN博客](https://blog.csdn.net/vip_iter/article/details/80123228)



# 分布式

​	微服务: 项目的一种架构方式(概念),如mvc架构

​	sc 则是这种架构的一种技术实现

​	同时微服务则一定需要分布式解决方案



与集群的区别:

-  分布式是指将不同的业务分布在不同的地方

- 集群指的是将几台服务器集中在一起，实现同一业务
- 分布式的每一个节点，都可以做集群，而集群并不一定就是分布式的。 而分布式，从狭义上理解，也与集群差不多，但是它的组织比较松散，不像集群，有一定组织性，一台服务器宕了，其他的服务器可以顶上来。分布式的每一个节点，都完成不同的业务，一个节点宕了，这个业务就不可访问了

## 场景

用户- 分布式session

报表-分布式调度

秒杀-分布式限流

订单-分布式id,分库分表,分布式事务



#  分布式id

传统方案: 自增/时间戳 uuid

分布式id特点:

1. 全局唯一
   - 应用只部署在一个服务器上,生成id唯一
   - 应用只部署在一个服务器上,生成id唯一
   - 应用只部署在同一个服务器上不同的docker容器中,生成id唯一
2. 高并发
3. 高可用



方案优缺点:

1. UUID 

   缺点: 1.空间占用多 2.索引效率低

2. 数据库自增组件

   缺点: 1.并发性能不高,受限于数据库性能  2. 针对缺点1 分库分表 需要改造 较复杂  3.业务数据容易泄露

3. redis自增

   优点: 并发性能相对方案2高

   缺点: 1. 数据丢失(rdb至少丢失1s数据,aof可以做到不丢失但地洞回复速度慢) 2.业务数据容易泄露

4. 雪花算法(snowflake)

   优点: 不依赖外部组件(如数据库,redis等)

   缺点: 时钟回拨

5. 号段模式

   缺点: 仍然依赖数据库,且仍然是自增

   优点: 一次获取多个可用id,性能提高



自研算法分析:

时间戳(ms) 同一ms可能有多个请求

时间戳(ms)+随机数  减少重复的概率,但无法完全保证唯一

时间戳(ms)+自增数(AtomicInteger) 同一台机器(容器)保证唯一,但多台机器无法保证

时间戳(ms)+机器序号+自增数(AtomicInteger)



雪花算法就是类似上述

比如:

1bit 符号位(舍弃)

41bit  时间戳

10bit 工作进程位=5bit 区域 + 5bit 机器序号

12bit 序列号位

大小可以自定义







## generator(百度)

雪花算法

https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md









## Tinyid(滴滴)

https://github.com/didi/tinyid

https://github.com/didi/tinyid/wiki

基于数据库号段算法

多DB,高可用,java-client

##  Leaf(美团)

号段模式和snowflake模式

https://github.com/Meituan-Dianping/Leaf/blob/master/README_CN.md

用到zookeeper,程序运行在docker等(手动配置不方便),自动上报服务器标识到zk,zk存储

分布式id以此为例(spring boot)

1. 引入依赖

   ```<dependency>
   <dependency>
   	<artifactId>leaf-boot-starter</artifactId>
       <groupId>com.sankuai.inf.leaf</groupId>
       <version>1.0.1-RELEASE</version>
   </dependency>
   ```

   1.1 若maven仓库没有 需要先下载install

   ```
   git clone git@github.com:Meituan-Dianping/Leaf.git
   或 
   git clone https://github.com/Meituan-Dianping/Leaf.git
   cd leaf
   git checkout feature/spring-boot-starter
   mvn clean install -Dmaven.test.skip=true 
   ```

2. 配置leaf.properties

   ```
   leaf.name=com.sankuai.leaf.opensource.test
   leaf.segment.enable=false
   #leaf.segment.url=
   #leaf.segment.username=
   #leaf.segment.password=
   
   leaf.snowflake.enable=false
   #leaf.snowflake.address=
   #leaf.snowflake.port=
   ```

3. @EnableLeafServer

4.     @Autowired
       private SegmentService segmentService;
       @Autowired
       private SnowflakeService snowflakeService;

5. 表结构(号段模式)

   ```
   CREATE DATABASE leaf;
   use leaf;
   CREATE TABLE `leaf_alloc` (
     `biz_tag` varchar(128)  NOT NULL DEFAULT '',
     `max_id` bigint(20) NOT NULL DEFAULT '1',
     `step` int(11) NOT NULL,
     `description` varchar(256)  DEFAULT NULL,
     `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
     PRIMARY KEY (`biz_tag`)
   ) ENGINE=InnoDB;
   
   insert into leaf_alloc(biz_tag, max_id, step, description) values('leaf-segment-test', 1, 2000, 'Test leaf Segment Mode Get Id')
   ```

   

6. ```
   @RequestMapping("/leaf")
   public class LeafController {
       @Autowired
       private SegmentService segmentService;
   /*    @Autowired
       private SnowflakeService snowflakeService;*/
   
       @GetMapping("/segment")
       public long segment(){
          return segmentService.getId("leaf-segment-test").getId(); //对应leaf-alloc biz_tag字段
       }
   }
   ```



雪花模式需要先搭建zk服务器



问题:

1. java.sql.SQLException: validateConnection false

   版本问题

   比如druid 1.0.18 需要匹配5.1.38的mysql-connector-java

   3.3.1的mybatis

   这里升级druid

   ```
   <dependency>
      <groupId>com.alibaba</groupId>
      <artifactId>druid</artifactId>
      <version>1.2.5</version>
   </dependency>
   <dependency>
   			<groupId>org.mybatis</groupId>
   			<artifactId>mybatis</artifactId>
   			<version>3.4.0</version>
   		</dependency>
   ```

   



# 分布式session

## 分类

### 传统session



![image-20220803135327995](assets/image-20220803135327995.png)



问题一: session存在哪里

​	一般情况下,session都是存储在内存中(服务器(tomcat)中),可以设置session持久化,在服务器重启时能够加载

问题二: nginx做了负载均衡,可能导致登录失效问题,怎么解决?

 1. 做某种规则,让特定用户访问特定服务器,如张三始终访问服务器1

    问题: 破坏了高可用,服务器1挂了,nginx的请求仍会转发到服务器1.

 2. 既然是session存在不同地方导致的,那就把session存在同一地方,如redis



session 原理:



![image-20220803142925996](assets/image-20220803142925996.png)

**浏览器第一次访问服务器的时候,服务器会生成一个sessionid,并返回给浏览器,这个sessionid会保存在浏览器的cookie会话中**

这个机制是根据浏览器中是不是有cookie,没有就重新生成(删除cookie记录后就没有了)

set-Cookie



问题:跨域

http://localhost:8080/ 

http://127.0.0.1:8080/

上述两个代表不同的域,当分别访问时会生成不同的cookie



总结:

1. 访问同一服务器下不同的web容器(如tomcat,可以是同一应用)生成不同的sessionId
2. 以不同域访问一个web容器(localhost,127.0.0.1 ),生成不同的sessionId

### spring-session

将session存到redis

1. redisTemplate
2. spring-session-data-redis

```
<dependency>
   <groupId>org.springframework.session</groupId>
   <artifactId>spring-session-data-redis</artifactId>
</dependency>
```

```
spring.session.store-type=redis
spring.session.timeout=3600
spring.session.redis.namespace=login:user //spring:Session扔存在,生成两份
```

如果redis集群配置的, spring.redis下配置



Spring Session makes it trivial(微不足道) to support clustered sessions without being tied to(be bounded to) an application container specific solution. It also provides transparent (透明)integration with

1. `HttpSession` - allows replacing the HttpSession in an application container (i.e. Tomcat) neutral(中立,非侵入式) way, with support for providing session IDs in headers to work with RESTful APIs

   原来Httpsession怎么用,现在就怎么用  `HttpSessionWrapper`

2. `WebSocket` - provides the ability to keep the HttpSession alive when receiving WebSocket messages

3. `WebSession` - allows replacing the Spring WebFlux’s WebSession in an application container neutral way



源码分析:

1. SessionRepositoryFilter.SessionRepositoryRequestWrapper implements HttpServletRequestWrapper

2. SessionRepositoryFilter.SessionRepositoryRequestWrapper implements HttpServletRequestWrapper
   SessionRepositoryFilter<S extends Session> extends OncePerRequestFilter

3. parent.doFilter -> child.doFilterInternal -> ApplicationFilterChain.doFilter ->Call the next filter if there is one(pos<n)

4. FilterChains

   ```
   0 = {ApplicationFilterConfig@10174} "ApplicationFilterConfig[name=characterEncodingFilter, filterClass=org.springframework.boot.web.servlet.filter.OrderedCharacterEncodingFilter]"
   1 = {ApplicationFilterConfig@10175} "ApplicationFilterConfig[name=sessionRepositoryFilter, filterClass=org.springframework.session.web.http.SessionRepositoryFilter]"
   2 = {ApplicationFilterConfig@10108} "ApplicationFilterConfig[name=formContentFilter, filterClass=org.springframework.boot.web.servlet.filter.OrderedFormContentFilter]"
   3 = {ApplicationFilterConfig@10176} "ApplicationFilterConfig[name=requestContextFilter, filterClass=org.springframework.boot.web.servlet.filter.OrderedRequestContextFilter]"
   4 = {ApplicationFilterConfig@10177} "ApplicationFilterConfig[name=Tomcat WebSocket (JSR356) Filter, filterClass=org.apache.tomcat.websocket.server.WsFilter]"
   ```

   

快捷键: ctrl+alt+左键 弹出实现(类和方法)

#### servlet和interceptor的区别

这两者在功能方面很类似,并且都是通过AOP(一种思想,横向切面,对OOP纵向扩展的补充)的具体技术实现.但在具体技术实现方面，差距还是比较大的.

区别:

- Filter是依赖于Servlet[容器](https://cloud.tencent.com/product/tke?from=10680)，属于Servlet规范的一部分，而拦截器则是独立存在的，可以在任何情况下使用。

- Filter的执行由Servlet容器回调完成，而拦截器通常通过动态代理的方式来执行。

  默认有上述5个

  ```
  @WebFilter(urlPatterns = "/*",filterName="filter3")
  public class MyFilter1 implements Filter {
  
      @Override
      public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
      	...
          chain.doFilter(request,response);
          ...
    }
  ```

  ApplicationFilterChain.doFilter 链式  

  ```
  ...
  filter.doFilter(request, response, this);
  ...
  return;
  ```

  先进入doFilter方法 后结束

- Filter的生命周期由Servlet容器管理，而拦截器则可以通过IoC容器来管理，因此可以通过注入等方式来获取其他Bean的实例，因此使用会更方便。

```
@Configuration
public class WebConfigure extends WebMvcConfigurerAdapter {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
//        registry.addInterceptor(new MyInterceptor1()).addPathPatterns("/**");
    }
}

public class MyInterceptor1 implements HandlerInterceptor {
```

注意: urlPatterns /*  pathPatterns /**





### token+redis

token+redis自由度高(移动端不太喜欢用cookie,以上两种都是基于cookie)

cookie的缺陷

1. 不安全
2. 大小有限,只能存储简单的字符串
3. 能够被禁用,删除



**token推荐存在header里**

@RequestHeader可以获得全部cookie

@CookieValue("SESSION") 从cookie中获取指定key的值

​	Cookie: 

​	JSESSIONID=40D2D611E06D4DB13DCD35F1B5220E0F; SESSION=ZGQzYTIyOTktODk0Yi00NDczLWJiNzktYjNkOWEyZDE5Nzc5;...









### jwt

JSON WEB TOKEN 一种协议

jwt.io



```
<dependency>
    <groupId>com.auth0</groupId>
    <artifactId>java-jwt</artifactId>
    <version>4.0.0</version>
</dependency>
```


#### 实例

Example using `HS256`

1. create

   ```
   Algorithm algorithm = Algorithm.HMAC256("token_secret");
   String token = JWT.create()
           .withClaim("login_user",username
           .withExpiresAt()  //TokenExpiredException
           .sign(algorithm);
   ```

2. verify

   ```
   Algorithm algorithm = Algorithm.HMAC256("token_secret");
   JWTVerifier verifier = JWT.require(algorithm)
           .build(); //Reusable verifier instance
   DecodedJWT jwt = verifier.verify(token); //JWTCreationException JWTDecodeException
   jwt.getClaim("login_user").asString()
   ```

3. DecodedJWT

   组成部分: header,payload,verify signature,token

   token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJsb2dpbl91c2VyIjoiYWRtaW4ifQ.Cq1TvoFJHvNjXhSecW1Kovx1Aymud3GXQEmThAH7evQ

   header=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9

   {
     "typ": "JWT",
     "alg": "HS256"
   }

   

   payload(data)=eyJsb2dpbl91c2VyIjoiYWRtaW4ifQ

   {
     "login_user": "admin"
   }

   

   signature=Cq1TvoFJHvNjXhSecW1Kovx1Aymud3GXQEmThAH7evQ

   ```
   HMACSHA256(
     base64UrlEncode(header) + "." +
     base64UrlEncode(payload),
     your-256-bit-secret
   )
   ```



当传递非之前生成的token 会报错(可解析,但防篡改)

```
com.auth0.jwt.exceptions.SignatureVerificationException: The Token's Signature resulted invalid when verified using the Algorithm: HmacSHA256
```

原因: 在生成jwt的时候Algorithm.HMAC256加入了自定义的`JWT_SECRET`,因此要妥善保存`JWT_SECRET`

#### claims

Claims are issued by(be provided by) a provider, and they are given one or more values and then packaged in security tokens that are issued by an issuer, commonly known as a security token(令牌) service (STS). Claim is **piece of information that describes given identity(身份) on some aspect**. Take claim as name-value pair

## 拦截器统一处理token

```
public class JwtInterceptor implements HandlerInterceptor {
    //如果该类注入了其他组件,如redisTemplate需要将该拦截器注册为组件,在WebConfigure注入
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        try {
            String token=request.getHeader("token");
            if(StringUtils.isBlank(token)){
                throw  new RuntimeException("token must be passed in header");
            }
            Algorithm algorithm = Algorithm.HMAC256("token_secret");
            JWTVerifier verifier = JWT.require(algorithm)
                    .build(); //Reusable

            // verifier instance
            DecodedJWT jwt = verifier.verify(token);
            //同一个request,session,redis都能存储
/*            request.getSession().setAttribute("login_user",
                    jwt.getClaim("login_user").asString());*/
            request.setAttribute("login_user",
                    jwt.getClaim("login_user").asString()); //@RequestAttribute
            return true;
        } catch (Exception exception){
            //Invalid signature/claims
            exception.printStackTrace();
        }
        return false;
    }
}
```

jwt.getClaim("login_user").asString() 注意数据类型 如果login_user是int类型,asString()->null



## Oauth2

授权机制,跟JWT完全不一样

比如qq授权慕课网(第三方)获取用户信息



spring-security-oauth2

1. 授权数据给第三方
2. 权限管理





# 分布式任务调度

场景

1. 报表

2. 日/月结单

3. 爬虫

4. 数据归档

   ...

总结: 基于时间+基于数据的任务调度



## 非分布式

@Scheduled

```
@Slf4j
@Component
@EnableScheduling
public class ScheduleJob {

    @SneakyThrows
    @Scheduled(fixedRate = 3000,initialDelay = 4000)
    public void shcedule(){
        log.info("job start....");
        Thread.sleep(2000);
        log.info("job end....");
    }
}
```

### 参数分析

```Number of units of time to delay before the first execution of a
Number of units of time to delay before the first execution of a fixedRate or fixedDelay task.
```

## 分布式

1. Quartz

2. Elasticjob

3. XXL-JOB

4. ScheduledX

5. PowerJob

   |                | QuartZ                           | xxl-job                                  | SchedulerX 2.0                                    | **PowerJob**                                                 |
   | -------------- | -------------------------------- | ---------------------------------------- | ------------------------------------------------- | ------------------------------------------------------------ |
   | 定时类型       | CRON                             | CRON                                     | CRON、固定频率、固定延迟、OpenAPI                 | **CRON、固定频率、固定延迟、OpenAPI**                        |
   | 任务类型       | 内置Java                         | 内置Java、GLUE Java、Shell、Python等脚本 | 内置Java、外置Java（FatJar）、Shell、Python等脚本 | **内置Java、外置Java（容器）、Shell、Python等脚本**          |
   | 分布式任务     | 有                               | 静态分片                                 | MapReduce 动态分片                                | **MapReduce 动态分片**                                       |
   | 在线任务治理   | 不支持                           | 支持                                     | 支持                                              | **支持**                                                     |
   | 日志白屏化     | 不支持                           | 支持                                     | 不支持                                            | **支持**                                                     |
   | 调度方式及性能 | 基于数据库锁，有性能瓶颈         | 基于数据库锁，有性能瓶颈                 | 不详                                              | **无锁化设计，性能强劲无上限**                               |
   | 报警监控       | 无                               | 邮件                                     | 短信                                              | **邮件，提供接口允许开发者扩展**                             |
   | 系统依赖       | 关系型数据库（MySQL、Oracle...） | MySQL                                    | 人民币                                            | **任意 Spring Data Jpa支持的关系型数据库（MySQL、Oracle...）** |
   | DAG 工作流     | 不支持                           | 不支持                                   | 支持                                              | **支持**                                                     |

   





















































# 分布式限流

# 分库分表

# 分布式事务

