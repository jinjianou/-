# 集群

集群调度架构 

[(3条消息) 十大主流集群调度系统大盘点_不正常IT研究所的博客-CSDN博客](https://blog.csdn.net/vip_iter/article/details/80123228)



# 分布式

​	微服务: 项目的一种架构方式(概念),如mvc架构

​	sc 则是这种架构的一种技术实现

​	同时微服务则一定需要分布式解决方案



与集群的区别:

-  分布式是指将不同的业务分布在不同的地方

- 集群指的是将几台服务器集中在一起，实现同一业务
- 分布式的每一个节点，都可以做集群，而集群并不一定就是分布式的。 而分布式，从狭义上理解，也与集群差不多，但是它的组织比较松散，不像集群，有一定组织性，一台服务器宕了，其他的服务器可以顶上来。分布式的每一个节点，都完成不同的业务，一个节点宕了，这个业务就不可访问了

## 场景

用户- 分布式session

报表-分布式调度

秒杀-分布式限流

订单-分布式id,分库分表,分布式事务



#  分布式id

传统方案: 自增/时间戳 uuid

分布式id特点:

1. 全局唯一
   - 应用只部署在一个服务器上,生成id唯一
   - 应用只部署在一个服务器上,生成id唯一
   - 应用只部署在同一个服务器上不同的docker容器中,生成id唯一
2. 高并发
3. 高可用



方案优缺点:

1. UUID 

   缺点: 1.空间占用多 2.索引效率低

2. 数据库自增组件

   缺点: 1.并发性能不高,受限于数据库性能  2. 针对缺点1 分库分表 需要改造 较复杂  3.业务数据容易泄露

3. redis自增

   优点: 并发性能相对方案2高

   缺点: 1. 数据丢失(rdb至少丢失1s数据,aof可以做到不丢失但地洞回复速度慢) 2.业务数据容易泄露

4. 雪花算法(snowflake)

   优点: 不依赖外部组件(如数据库,redis等)

   缺点: 时钟回拨

5. 号段模式

   缺点: 仍然依赖数据库,且仍然是自增

   优点: 一次获取多个可用id,性能提高



自研算法分析:

时间戳(ms) 同一ms可能有多个请求

时间戳(ms)+随机数  减少重复的概率,但无法完全保证唯一

时间戳(ms)+自增数(AtomicInteger) 同一台机器(容器)保证唯一,但多台机器无法保证

时间戳(ms)+机器序号+自增数(AtomicInteger)



雪花算法就是类似上述

比如:

1bit 符号位(舍弃)

41bit  时间戳

10bit 工作进程位=5bit 区域 + 5bit 机器序号

12bit 序列号位

大小可以自定义







## generator(百度)

雪花算法

https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md









## Tinyid(滴滴)

https://github.com/didi/tinyid

https://github.com/didi/tinyid/wiki

基于数据库号段算法

多DB,高可用,java-client

##  Leaf(美团)

号段模式和snowflake模式

https://github.com/Meituan-Dianping/Leaf/blob/master/README_CN.md

用到zookeeper,程序运行在docker等(手动配置不方便),自动上报服务器标识到zk,zk存储

分布式id以此为例(spring boot)

1. 引入依赖

   ```<dependency>
   <dependency>
   	<artifactId>leaf-boot-starter</artifactId>
       <groupId>com.sankuai.inf.leaf</groupId>
       <version>1.0.1-RELEASE</version>
   </dependency>
   ```

   1.1 若maven仓库没有 需要先下载install

   ```
   git clone git@github.com:Meituan-Dianping/Leaf.git
   或 
   git clone https://github.com/Meituan-Dianping/Leaf.git
   cd leaf
   git checkout feature/spring-boot-starter
   mvn clean install -Dmaven.test.skip=true 
   ```

2. 配置leaf.properties

   ```
   leaf.name=com.sankuai.leaf.opensource.test
   leaf.segment.enable=false
   #leaf.segment.url=
   #leaf.segment.username=
   #leaf.segment.password=
   
   leaf.snowflake.enable=false
   #leaf.snowflake.address=
   #leaf.snowflake.port=
   ```

3. @EnableLeafServer

4.     @Autowired
       private SegmentService segmentService;
       @Autowired
       private SnowflakeService snowflakeService;

5. 表结构(号段模式)

   ```
   CREATE DATABASE leaf;
   use leaf;
   CREATE TABLE `leaf_alloc` (
     `biz_tag` varchar(128)  NOT NULL DEFAULT '',
     `max_id` bigint(20) NOT NULL DEFAULT '1',
     `step` int(11) NOT NULL,
     `description` varchar(256)  DEFAULT NULL,
     `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
     PRIMARY KEY (`biz_tag`)
   ) ENGINE=InnoDB;
   
   insert into leaf_alloc(biz_tag, max_id, step, description) values('leaf-segment-test', 1, 2000, 'Test leaf Segment Mode Get Id')
   ```

   

6. ```
   @RequestMapping("/leaf")
   public class LeafController {
       @Autowired
       private SegmentService segmentService;
   /*    @Autowired
       private SnowflakeService snowflakeService;*/
   
       @GetMapping("/segment")
       public long segment(){
          return segmentService.getId("leaf-segment-test").getId(); //对应leaf-alloc biz_tag字段
       }
   }
   ```



雪花模式需要先搭建zk服务器



问题:

1. java.sql.SQLException: validateConnection false

   版本问题

   比如druid 1.0.18 需要匹配5.1.38的mysql-connector-java

   3.3.1的mybatis

   这里升级druid

   ```
   <dependency>
      <groupId>com.alibaba</groupId>
      <artifactId>druid</artifactId>
      <version>1.2.5</version>
   </dependency>
   <dependency>
   			<groupId>org.mybatis</groupId>
   			<artifactId>mybatis</artifactId>
   			<version>3.4.0</version>
   		</dependency>
   ```

   



# 分布式session

## 分类

### 传统session



![image-20220803135327995](assets/image-20220803135327995.png)



问题一: session存在哪里

​	一般情况下,session都是存储在内存中(服务器(tomcat)中),可以设置session持久化,在服务器重启时能够加载

问题二: nginx做了负载均衡,可能导致登录失效问题,怎么解决?

 1. 做某种规则,让特定用户访问特定服务器,如张三始终访问服务器1

    问题: 破坏了高可用,服务器1挂了,nginx的请求仍会转发到服务器1.

 2. 既然是session存在不同地方导致的,那就把session存在同一地方,如redis



session 原理:



![image-20220803142925996](assets/image-20220803142925996.png)

**浏览器第一次访问服务器的时候,服务器会生成一个sessionid,并返回给浏览器,这个sessionid会保存在浏览器的cookie会话中**

这个机制是根据浏览器中是不是有cookie,没有就重新生成(删除cookie记录后就没有了)

set-Cookie



问题:跨域

http://localhost:8080/ 

http://127.0.0.1:8080/

上述两个代表不同的域,当分别访问时会生成不同的cookie



总结:

1. 访问同一服务器下不同的web容器(如tomcat,可以是同一应用)生成不同的sessionId
2. 以不同域访问一个web容器(localhost,127.0.0.1 ),生成不同的sessionId

### spring-session

将session存到redis

1. redisTemplate
2. spring-session-data-redis

```
<dependency>
   <groupId>org.springframework.session</groupId>
   <artifactId>spring-session-data-redis</artifactId>
</dependency>
```

```
spring.session.store-type=redis
spring.session.timeout=3600
spring.session.redis.namespace=login:user //spring:Session扔存在,生成两份
```

如果redis集群配置的, spring.redis下配置



Spring Session makes it trivial(微不足道) to support clustered sessions without being tied to(be bounded to) an application container specific solution. It also provides transparent (透明)integration with

1. `HttpSession` - allows replacing the HttpSession in an application container (i.e. Tomcat) neutral(中立,非侵入式) way, with support for providing session IDs in headers to work with RESTful APIs

   原来Httpsession怎么用,现在就怎么用  `HttpSessionWrapper`

2. `WebSocket` - provides the ability to keep the HttpSession alive when receiving WebSocket messages

3. `WebSession` - allows replacing the Spring WebFlux’s WebSession in an application container neutral way



源码分析:

1. SessionRepositoryFilter.SessionRepositoryRequestWrapper implements HttpServletRequestWrapper

2. SessionRepositoryFilter.SessionRepositoryRequestWrapper implements HttpServletRequestWrapper
   SessionRepositoryFilter<S extends Session> extends OncePerRequestFilter

3. parent.doFilter -> child.doFilterInternal -> ApplicationFilterChain.doFilter ->Call the next filter if there is one(pos<n)

4. FilterChains

   ```
   0 = {ApplicationFilterConfig@10174} "ApplicationFilterConfig[name=characterEncodingFilter, filterClass=org.springframework.boot.web.servlet.filter.OrderedCharacterEncodingFilter]"
   1 = {ApplicationFilterConfig@10175} "ApplicationFilterConfig[name=sessionRepositoryFilter, filterClass=org.springframework.session.web.http.SessionRepositoryFilter]"
   2 = {ApplicationFilterConfig@10108} "ApplicationFilterConfig[name=formContentFilter, filterClass=org.springframework.boot.web.servlet.filter.OrderedFormContentFilter]"
   3 = {ApplicationFilterConfig@10176} "ApplicationFilterConfig[name=requestContextFilter, filterClass=org.springframework.boot.web.servlet.filter.OrderedRequestContextFilter]"
   4 = {ApplicationFilterConfig@10177} "ApplicationFilterConfig[name=Tomcat WebSocket (JSR356) Filter, filterClass=org.apache.tomcat.websocket.server.WsFilter]"
   ```

   

快捷键: ctrl+alt+左键 弹出实现(类和方法)

#### servlet和interceptor的区别

这两者在功能方面很类似,并且都是通过AOP(一种思想,横向切面,对OOP纵向扩展的补充)的具体技术实现.但在具体技术实现方面，差距还是比较大的.

区别:

- Filter是依赖于Servlet[容器](https://cloud.tencent.com/product/tke?from=10680)，属于Servlet规范的一部分，而拦截器则是独立存在的，可以在任何情况下使用。

- Filter的执行由Servlet容器回调完成，而拦截器通常通过动态代理的方式来执行。

  默认有上述5个

  ```
  @WebFilter(urlPatterns = "/*",filterName="filter3")
  public class MyFilter1 implements Filter {
  
      @Override
      public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
      	...
          chain.doFilter(request,response);
          ...
    }
  ```

  ApplicationFilterChain.doFilter 链式  

  ```
  ...
  filter.doFilter(request, response, this);
  ...
  return;
  ```

  先进入doFilter方法 后结束

- Filter的生命周期由Servlet容器管理，而拦截器则可以通过IoC容器来管理，因此可以通过注入等方式来获取其他Bean的实例，因此使用会更方便。

```
@Configuration
public class WebConfigure extends WebMvcConfigurerAdapter {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
//        registry.addInterceptor(new MyInterceptor1()).addPathPatterns("/**");
    }
}

public class MyInterceptor1 implements HandlerInterceptor {
```

注意: urlPatterns /*  pathPatterns /**





### token+redis

token+redis自由度高(移动端不太喜欢用cookie,以上两种都是基于cookie)

cookie的缺陷

1. 不安全
2. 大小有限,只能存储简单的字符串
3. 能够被禁用,删除



**token推荐存在header里**

@RequestHeader可以获得全部cookie

@CookieValue("SESSION") 从cookie中获取指定key的值

​	Cookie: 

​	JSESSIONID=40D2D611E06D4DB13DCD35F1B5220E0F; SESSION=ZGQzYTIyOTktODk0Yi00NDczLWJiNzktYjNkOWEyZDE5Nzc5;...









### jwt

JSON WEB TOKEN

## 拦截器统一处理token

## Oauth2



# 分布式任务调度

# 分布式限流

# 分库分表

# 分布式事务

