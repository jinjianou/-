# 复杂度

* 常数时间操作： 执行时间**不以样本数据量为转移**，每次执行事件都是相对固定的。如array[index],算数运算，位运算,赋值，比较，自增减.....
* 时间复杂度就是发生了多少次常数时间操作(忽略低阶项和高阶系数)
* 流程
  * 想象该算法所处理的数据状况，按照**最差情况**来
  * 将整个流程彻底拆分成**基本动作（常数时间）**
  * 计算如果数据量为n，基本动作的数量和N之间的关系

* O big-O 最差情况
* 额外空间复杂度 **作为输出结果的空间，不算额外空间**，如返回int[] 流程中申请了int[]不计算在流程的空间复杂度计算
* 相同时间复杂度优劣比较，需要比较常数项，需要通过实验数据运行时间比较（理论分析困难，如都是常数运算 位运算 > +- > */）
* 最优解：首先时间复杂度，其次空间复杂度，最后常数项时间

# 对数器（测试）

1. 有一个你需要测试的方法a
2. 有一个确定正确的方法b（一般采用系统提供的，如Arrays.asList）
3. 实现一个随机样本产生器
4. a,b跑相同的随机样本 ,查看结果是否一样

```
public class Checktor {
    public static void main(String[] args) {
        int checkTime=50000;
        int[] data1 = Generator.getInstance().generator(100, 1000);
        int[] data2 = Arrays.copyOf(data1, data1.length);
        boolean success=true;
        for (int i = 0; i < checkTime; i++) {
            a(data1);
            Arrays.sort(data2);
            if(!Generator.getInstance().isEquals(data1,data2)){
                success=false;
                System.out.println("failed");
                System.out.println(Arrays.toString(data1));
                System.out.println(Arrays.toString(data2));
                break;
            }
        }
        if (success){
            System.out.println("nice, the method is right");
        }
    }

    public static void a(int[] arr){
        for (int i = 1; i < arr.length; i++) {
            for (int j = i-1; j >=0 && arr[j]>arr[j+1] ; j--) {
                swap(arr,j,j+1);
            }
        }
    }

    private static void swap(int[] arr, int j, int i) {
        int tmp=arr[j];
        arr[j]=arr[j+1];
        arr[j+1]=tmp;
    }
}

class Generator{
    private volatile static Generator generator;
    private Generator(){}
    public static Generator getInstance(){
        if (generator==null){
            synchronized (Generator.class){
                if(generator==null){
                    generator=new Generator();
                }
            }
        }
        return generator;
    }
    int[] generator(int maxSize,int maxValue){
        Random random = new Random();
        int[] arr = new int[random.nextInt(maxSize + 1)];
        for (int i = 0; i < arr.length; i++) {
            arr[i]=random.nextInt(maxValue+1)-random.nextInt(maxValue+1);
        }
        return arr;
    }
    boolean isEquals(int[] arr1,int[] arr2){
        Preconditions.checkNotNull(arr1,"arr1 is null");
        Preconditions.checkNotNull(arr2,"arr2 is null");
        if (arr1.length!=arr2.length){
            return false;
        }
        for (int i = 0; i < arr1.length; i++) {
            if(arr1[i]!=arr2[i]){
                System.out.println(i);
                return false;
            }
        }
        return true;
    }
}
```

# 局部最小问题

1）arr[0]<arr[1]

2）arr[len-1]<arr[len-2]

3)   arr[M]<arr[M-1] && arr[M]<arr[M+1]

则0,len-1,M称之为局部最小点

现在有一个无序数组，且相邻元素值不同，求任一局部最小点

结论1： 下降上升区间必有局部最小点（可结合图像）



# 异或

1) N^N=0

2) 0^N=N

1. 不许额外变量交换a,b

   a=a^b; b=a^b; a=a^b;

2. 一个数组中有一种数出现奇数次，其他偶数次，求该值

   所有元素异或结果就是该值

3. 获取一个整型数二进制表示最右侧的1

   ```
   int x=0b011111000;
   int y=0b000000001;
   int count=0;
   while (((x^y)&y)==y){
       y<<=1;
       count++;
   }
   ```

   或者  x&((~x)+1)

4. 一个数组中有**两种数**出现奇数次，其他偶数次，求该值

   数组遍历异或的结果 eor=a^b !=0   在k位上为1 将数组分为k位是0和1两组

   对 比如堆1组异或的结果就是a，另一个就是b=eor^a



# 堆

一种完全二叉树  

数组表示 i节点的左 i<<1 右 i<<1+1 父 i/2  (数组下标从1开始存储)

大顶/小顶

* 添加元素
  
* 自底向上
  
* 删除对顶元素并保持堆特性
  
  * 用最后一个元素代替堆顶元素 自顶向下
* 对一个无序数组，使其成为堆
  * 自顶而下 一个个插入 O(n*logn)
  * 自底而上 N/2*1+N/4+....  O(N)

* 堆排序
  * 插入所有元素形成初始堆 O(n*logn)/O(N)
  * 交换0和size-1元素后 调整剩余size-1个元素的堆特性，重复size-1次  O(n*logn)

* PriorityQueue 默认小根堆

* 对一个基本有序的数组（基本有序只的是每个元素原始位置到排序后的位置之间的移动距离不超过k），采取合适的排序策略

  首先将0~k的元素创建堆，获取极值 -> 0

  将k+1的元素放入上述堆，获取极值 -> 1

  以此类推，将所有值排序

  ```
  PriorityQueue<Integer> heap=new PriorityQueue<>();
  
  int[] arr={2,4,6,1,5,3,9,7};
  int k=4;
  for (int i = 0; i <= Math.min(arr.length-1,k); i++) {
      heap.add(i);
  }
  int j=Math.min(arr.length-1,k)+1;
  for (int i = 0; i < arr.length; i++) {
      if (!heap.isEmpty()){
          arr[i]=heap.poll();
      }
      if(j<arr.length){
          heap.add(arr[j]);
          j++;
      }
  }
  ```

* 比较器  -1 表示第一个参数在前面

正数的表示

* 原码=反码=补码

负数的表示

* 原码 -5 11000 0101

* 反码 除符号位取反  -5 1111 1010

* 补码 反码+1

* **计算机中负数用补码表示**

  

## 表

* 快慢指针

  * 输入链表表头，奇数长度返回中点，偶数则上中点

    ```
    if(head==null||head.next==null){
        return head;
    }
    Node<String> low=head;
    Node<String> fast=head.next;
    
    int size=3;
    while (fast.next!=null){
        if((size&1)==1){
            low=low.next;
        }
        fast=fast.next;
        size++;
    }
    return low;
    ```

    优化：**快指针一次走两步，慢指针一次一步**

    ```
    if(head==null||head.next==null||head.next.next==null){
        return head;
    }
    Node<String> low=head.next;
    Node<String> fast=head.next.next;
    
    while (fast.next!=null&&fast.next.next!=null){
        low=low.next;
        fast=fast.next.next;
    }
    return low;
    ```

  * 输入链表表头，奇数长度返回中点，偶数则下中点

    ```
    if(head==null||head.next==null){
        return head;
    }
    Node<String> low=head.next;
    Node<String> fast=head.next;
    
    while (fast.next!=null&&fast.next.next!=null){
        low=low.next;
        fast=fast.next.next;
    }
    return low;
    ```

  * 输入链表表头，奇数长度返回中点前一个，偶数则上中点前一个

    ```
    if(head==null||head.next==null||head.next.next==null){
        return null;
    }
    Node<String> low=head;
    Node<String> fast=head.next.next;
    
    while (fast.next!=null&&fast.next.next!=null){
        low=low.next;
        fast=fast.next.next;
    }
    return low;
    ```

  * 输入链表表头，奇数长度返回中点前一个，偶数则下中点前一个

    ```
    if(head==null||head.next==null){
        return null;
    }
    Node<String> low=head;
    Node<String> fast=head.next;
    
    while (fast.next!=null&&fast.next.next!=null){
        low=low.next;
        fast=fast.next.next;
    }
    return low;
    ```

* 一个单链表，判断是不是回文链表

  * 考虑用栈辅助

    ```
    LinkedList<Node> stack = new LinkedList<Node>();
    Node cur=head;
    while (cur!=null){
        stack.offer(cur);
        cur=cur.next;
    }
    cur=head;
    while (cur!=null){
        if(!cur.value.equals(stack.pollLast().value)){
            return false;
        }
        cur=cur.next;
    }
    return true;
    ```

  * 考虑通过更改链表元素next的方式

    ```
    if(head==null){
        return true;
    }
    //1.获取奇数中点，偶数上中点
    Node mid=mid5(head);
    //2. 改变链表顺序，让中点右边的节点往左
    Node last=mid;
    Node cur=mid.next;
    mid.next=null;
    Node prev;
    while (cur!=null){
        prev=cur.next;
    
        cur.next=last;
        last=cur;
        cur=prev;
    
    }
    //3.双指针 L指针 head,R指针 last 从两端到中点
    Node l=head;
    Node r=last;
    while(l!=null&&l.value.equals(r.value)){
        l=l.next;
        r=r.next;
    }
    if(l!=null){
        return false;
    }
    
    return true;
    ```

  

* 给定一个值k,将单链表分成成左边小、中间相等、右边大的形式

  * 将链表放入数组中，在数组上做partition
  * 分成小、中、大三部分，再把各部分之间串起来

  一个无序单向链表，给一个base,实现荷兰旗（左区<base 右区>base）

1. 为< = >区分别设置2个头尾指针

```
Node<Integer> cur=head;
Node<Integer> next;
//为< = >区分别设置2个头尾指针 partition
Node<Integer> lh=null,lt=null;
Node<Integer> eh=null,et=null;
Node<Integer> gh=null,gt=null;
while (cur!=null){
    next=cur.next;
    //unload next
    cur.next=null;
    if(cur.value.compareTo(base)<0){
        if(lh==null){
            lh=cur;
        }else{
            lt.next=cur;
        }
        lt=cur;
    }else if(base.equals(cur.value)){
        if(eh==null){
            eh=cur;
        }else{
            et.next=cur;
        }
        et=cur;
    }else{
        if(gh==null){
            gh=cur;
        }else{
            gt.next=cur;
        }
        gt=cur;
    }
    cur=next;
}
// merge
Node<Integer> newHead=null, connectNext=null;
Node[] nodes={lh,lt,eh,et,gh,gt};
for (int i = 0; i < nodes.length; i+=2) {
    if(nodes[i]!=null){
        if(newHead==null){
            newHead=nodes[i];
        }else{
            connectNext.next=nodes[i];
        }
        connectNext=nodes[i+1];
    }
}
//iter
while (newHead!=null){
    System.out.print(newHead.value+", ");
    newHead=newHead.next;
}
System.out.println( );
return null;
```

2. 将链表放在数组中，转化为荷兰旗问题

* 荷兰旗问题

  现有n个红白蓝三种不同颜色的小球，乱序排列在一起，请通过两两交换任意两个球，使得从左至右，依次是一些红球、一些白球、一些蓝球。

  联想到快读排序，依托于一个partition分治过程，设定三个指针完成重新排列，使得所有球排列成三个不同颜色的球

```
/**
 *
 * 三个指针 begin end cur
 * 1. cur==1 cur begin交换 begin++ cur++
 * 2. cur==2  cur++
 * 3. cur==3  cur end交换 end--
 */
int[] arr={1,2,3,2,1,1,3,2,1,3,2,1,2};
int begin=0,end=arr.length-1;
int cur=0;
while (cur<end){
    while (arr[cur]==1){
        if(cur!=begin) swap(arr,cur,begin);
        begin++;
        cur++;
    }
    if(arr[cur]==2){
        cur++;
    }
    while (cur<end&&arr[cur]==3){
        swap(arr,cur,end);
        end--;
    }
}
```

* 有一个数据结构为

  class Node{

  ​	.....

  ​	Node rand;

  ​	....

  }

  rand代表当前结点可以指向任何结点或null

  设计一种方式实现一个单项无环链表的**深拷贝**，并返回头结点

  

  ​	1.  使用hash表 key原结点,value是新结点，遍历两次

  ```
  //第一遍存表
          HashMap<Node<Integer>, Node<Integer>> map = new HashMap<>();
          Node<Integer> cur=head;
          while (cur!=null){
              map.put(cur,new Node<>( cur.value));
              cur=cur.next;
          }
          //第二遍链接
        cur=head;
          while (cur!=null){
              Node<Integer> newNode = map.get(cur);
              newNode.next=map.get(cur.next);
  //            newNode.rand=map.get(cur.rand);
              cur=cur.next;
          }
          return map.get(head);
  ```

  2. 成对构造结点，将新结点作为老节点的next,第一遍设置next，第二遍设置rand

* 两个可能成环或无环的单链表，head1和head2 , 求出第一个相交的结点

  第一步 求出成环的第一个结点(可以用set)

  设外环a，内环b

  1.   f 一次2步,s一次一步

     假设 经过k轮 sf相遇
     s k  a+m*b+ind
     f 2k a+n*b+ind

     一式*2  两式做差可知a+ind=(n-2m)*b

  2. f->1 并回到原点
     s在原地 还是一次1步

     s a+m2*b+ind2
     f a+n*b+ind+h

     将1式代入二式 得2a+(n+m2)*b+ind+ind2

     上式一定可以化成a+kb+ind2的形式 

     即(a+ind+ind2)%b==0 所以ind2===0

     ```
     //1. f 2 head s 1 head
     if (head==null||head.next==null||head.next.next==null){
         return null;
     }
     Node<Integer> fast=head.next.next,slow=head.next;
     while (fast!=slow){
         if(fast.next==null||fast.next.next==null){
             return null;
         }
         fast=fast.next.next;
         slow=slow.next;
     }
     //2. f 1 head s 1 current
     fast=head;
     while (fast!=slow){
         fast=fast.next;
         slow=slow.next;
     }
     return fast;
     ```

  第二步 分情况讨论

  1. loop1==null && loop1==null 即双方都无环

     Y字型 

     1. set集合

     2. head1->len1,head2->len2  先判断end节点不同不相交，相同长的那个链表先走|len1-len2|步，然后同时next，会在某个点相交

        **单链表只有一个next**

  2. 一个loop有环  不可能相交

  3. 两者loop都有环

     1. 两环相交

     2. 两环不相交

        通过第一步拿到的入环结点，set集合

* 要删除单链表中的某个结点，给要删除的节点，但不给头结点

  取巧方法： 将node.next->node  node.next.next->node

  问题：无法删除最后一个非空结点，只是修改原结点的数据

## 二叉树

### 基本

#### 结构描述

```
class Node<T>{
    T value;
    Node<T> left;
    Node<T> right;
}
```

#### 先序 中序 后序  	

​	头结点的位置

1. 递归

   递归序 第一次先序 第二次中序 第三次后序

   ```
   if (root==null) {
       return;
   }
   //System.out.print(root.value + ",");
   preOrder(root.left);
   preOrder(root.right);
   ```

2. 非递归

   1. 任何递归函数都可以转为非递归

   2. 设计压栈实现

      前序

      ```
      if(root==null){
          return;
      }
      LinkedList<Node<Integer>> stack = new LinkedList<>();
      stack.offerLast(root);
      
      while (!stack.isEmpty()){
          Node<Integer> node = stack.pollLast();
          System.out.print(node.value+",");
          if(node.right!=null) {
              stack.offerLast(node.right);
          }
          if(node.left!=null) {
              stack.offerLast(node.left);
          }
      }
      ```

      后序：两个栈s1,s2(辅助)，最后输出s2

      ```
if(root==null){
          return;
      }
      LinkedList<Node<Integer>> stack1 = new LinkedList<>();
      LinkedList<Node<Integer>> stack2 = new LinkedList<>();
      stack1.offerLast(root);
      while (!stack1.isEmpty()){
          Node<Integer> node = stack1.pollLast();
          stack2.offerLast(node);
          if(node.left!=null) {
              stack1.offerLast(node.left);
          }
          if(node.right!=null) {
              stack1.offerLast(node.right);
          }
      }
      
      while (!stack2.isEmpty()){
          System.out.print(stack2.pollLast().value+",");
      }
      ```
      
      中序：先一直向左直到空，弹出放右，然后重复
      
      ```
      static void iterLeft(Node<Integer> cur,LinkedList<Node<Integer>> stack){
          stack.offerLast(cur);
      
          while (cur.left != null) {
              stack.offerLast(cur.left);
              cur = cur.left;
          }
      }
      static void mediumOrder2(Node<Integer> root){
          if(root==null){
              return;
          }
          LinkedList<Node<Integer>> stack = new LinkedList<>();
          //iter left tree
          iterLeft(root,stack);
          //iter right tree
          while (!stack.isEmpty()){
              Node<Integer> top = stack.pollLast();
              System.out.print(top.value+",");
              if(top.right!=null){
                  iterLeft(top.right,stack);
              }
          }
      }
      ```
      
      ```
      if (root == null) {
          return;
      }
      LinkedList<Node<Integer>> stack = new LinkedList<>();
      Node<Integer> h=root;
      while (!stack.isEmpty()||h!=null){
          if(h!=null){
              stack.offerLast(h);
              h=h.left;
          }else{
              Node<Integer> top = stack.pollLast();
              System.out.print(top.value+",");
              h=top.right;
          }
      }
      ```

### 按层遍历

- 通过队列实现宽度优先

```
if(root==null){
    return;
}
LinkedList<Node<Integer>> queue = new LinkedList<>();
queue.offerLast(root);
while (!queue.isEmpty()){
    Node<Integer> top = queue.pollFirst();
    System.out.print(top.value+",");
    if(top.left!=null){
        queue.offerLast(top.left);
    }
    if(top.right!=null){
        queue.offerLast(top.right);
    }
}
```

- 在上述的基础上，统计最大宽度，即发现某一层的开始结束

  ```
  static int getMaxWidth(Node<Integer> root){
      if(root==null){
          return 0;
      }
      LinkedList<Node<Integer>> queue = new LinkedList<>();
      queue.offerLast(root);
      Map<Node<Integer>, Integer> map = new HashMap<>();//key 结点 value 所在层数
      map.put(root,1);
      int curLevel=1; //当前遍历的层数
      int curLevelNodes=0; //当前层的节点数
      int max=0; //最大结点数
      while (!queue.isEmpty()){
          Node<Integer> curNode = queue.pollFirst();
          int curNodeLevel=map.get(curNode);
          if(curNode.left!=null){
              queue.offerLast(curNode.left);
              map.put(curNode.left,curNodeLevel+1);
          }
          if(curNode.right!=null){
              queue.offerLast(curNode.right);
              map.put(curNode.right,curNodeLevel+1);
          }
          if(curNodeLevel==curLevel){
              curLevelNodes++;
          }else{
              max=Math.max(max,curLevelNodes);
              System.out.println("curLevelNodes= "+curLevelNodes+", max= "+max);
              curLevel++;
              curLevelNodes=1;
          }
      }
      return Math.max(max,curLevelNodes);
  }
  ```

### 序列化与反序列化

1. 用什么方式（先中后序，按层遍历）序列化，反序列化用相同的方式

2. **填充空结点（包括叶子节点的子结点）以保证树结构**

3. 以按层遍历为例子

   ```
   //null 只序列化不加入遍历队列，非null 序列化并且加入遍历队列
           if(root==null){
               return null;
           }
           LinkedList<Node<Integer>> queue = new LinkedList<>();
           LinkedList<String> serialRs = new LinkedList<>();
           queue.offerLast(root);
           serialRs.offerLast(String.valueOf(root.value));
           while (!queue.isEmpty()){
               Node<Integer> top = queue.pollFirst();
   //            System.out.print(top.value+",");
               if(top.left!=null){
                   queue.offerLast(top.left);
                   serialRs.offerLast(String.valueOf(top.left.value));
               }else{
                   serialRs.offerLast(null);
               }
               if(top.right!=null){
                   queue.offerLast(top.right);
                   serialRs.offerLast(String.valueOf(top.right.value));
               }else{
                   serialRs.offerLast(null);
               }
           }
           return serialRs;
   ```

```
static Node<Integer> withIterDeSerializable(LinkedList<String> serials){
    if(serials==null || serials.size()==0){
        return null;
    }
    LinkedList<Node<Integer>> queue = new LinkedList<>();
    Node<Integer> head = generateNode(serials.pollFirst());
    queue.offerLast(head);
    while (!queue.isEmpty()){
        Node<Integer>  node= queue.pollFirst();
        node.left=generateNode(serials.pollFirst());
        node.right=generateNode(serials.pollFirst());
        if(node.left!=null){
            queue.offerLast(node.left);
        }
        if(node.right!=null){
            queue.offerLast(node.right);
        }
    }
    return head;
}

private static Node<Integer> generateNode(String val) {
    if(val==null){
        return null;
    }
    return new Node<Integer>(Integer.valueOf(val),null,null);
}
```

## 递归

### 并查集

并查集被很多OIer认为是最简洁而优雅的数据结构之一，主要用于解决一些**元素分组**的问题。它管理一系列**不相交的集合**，并支持两种操作：

- **合并**（Union）：把两个不相交的集合合并为一个集合。
- **查询**（Find）：查询两个元素是否在同一个集合中

并查集的重要思想在于，**用集合中的一个元素代表集合**。我曾看过一个有趣的比喻，把集合比喻成**帮派**，而代表元素则是**帮主**。接下来我们利用这个比喻，看看并查集是如何运作的。

初始化:所有大侠各自为战。他们各自的帮主自然就是自己

合并:找到帮主各自的帮主pk合并

查找:一步步向上找(直到根结点)

方案一:

```
static void init(int n){
    for (int i = 0; i < n; i++) {
        fa[i]=i;
    }
}

static int find(int x){
    if(fa[x]==x){
        return x;
    }
    return find(fa[x]);
}

static void union(int x,int y){
    int fa1=find(x);
    int fa2=find(y);
    if(fa1!=fa2) {
            fa[fa2] = fa1;
    }
}
```

该方案存在问题,当链越来越长,底部结点找到根结点的效率越来越低



方案二(路径压缩):

**即将沿途的每个节点的父节点都设为根节点**

```
if(fa[x]==x){
    return x;
}else{
    fa[x] =find(fa[x]); // 将父结点设为根节点
    return fa[x];
}
```



方案三(效率继续提升):

将简单树合并到复杂树以减少 **按秩合并**

```
static void init(int n){
        for (int i = 0; i < n; i++) {
            fa[i]=i;
            rank[i]=0;
        }
    }
  

    static void union(int x,int y){
        int fa1=find(x);
        int fa2=find(y);
        if(fa1==fa2) return;
        if(rank[x]<=rank[y]){
            fa[x]=y;
        }else{
            fa[y]=x;
        }
        if(rank[x]==rank[y]){
            //x y树深度相同,则新树深度+1
            rank[y]++;
        }
    }

```

案例: 多个user只要有一个属性相同就认定是同一集合

```
class Solution {
    static List<Integer> fa=new ArrayList<>(10);
    static List<Integer> rank=new ArrayList<>(10);
    static ArrayList<User> users;
    static void userInit(){
        //静态代码块中的变量是局部变量,只在块内有效
        users = new ArrayList<>();
        users.add(new User(1,2,3));
        users.add(new User(2,2,3));
        users.add(new User(6,4,5));
        users.add(new User(7,2,8));
        users.add(new User(11,12,13));
        users.add(new User(4,9,10));
        users.add(new User(1,2,3));
    }
    public static void main(String[] args) {
        userInit();
        init();
        for (int i = 0; i < users.size()-1; i++) {
            for (int j = i+1; j < users.size(); j++) {
                union(i,j);
            }
        }

        System.out.println(fa);
    }

    static void init(){
        for (int i = 0; i < users.size(); i++) {
            fa.add(i);
            rank.add(0);
        }
    }

    static int find(Integer x){
        if(Objects.equals(fa.get(x),x)){
            return x;
        }else{
            fa.set(x,find(fa.get(x)));
            return fa.get(x);
        }

    }

    static void union(Integer x,Integer y){
        User user1 = users.get(x);
        User user2 = users.get(y);
        if(user1.unionEqual(user2)) {
            if (rank.get(x) <= rank.get(y)) {
                fa.set(x, fa.get(y));
            } else {
                fa.set(y, fa.get(x));
            }
            if (Objects.equals(rank.get(x), rank.get(y))) {
                rank.set(y, rank.get(y) + 1);
            }
        }
    }

}
class User{
    Integer a;
    Integer b;
    Integer c;

    public User(Integer a, Integer b, Integer c) {
        this.a = a;
        this.b = b;
        this.c = c;
    }

    public boolean unionEqual(User user){
       if( Objects.equals(this.a,user.a)) return true;
       if( Objects.equals(this.b,user.b)) return true;
       return Objects.equals(this.c,user.c);
    }

}
```



### 图的表示

​	以下表示都算直接距离: 

1. 邻接表
2. 邻接矩阵



创建图:

```
class Graph{
    HashMap<Integer,Node> nodes;
    HashSet<Edge> edges;

    public Graph() {
        nodes=new HashMap<>();
        edges=new HashSet<>();
    }
    
}

class Node{
    int value; //结点值 此时为编号
    int in;
    int out;
    List<Node> nextNodes; //出结点集合
    List<Edge> nextEdges; //出边集合

    public Node(int value){
        this.value=value;
        in=0;
        out=0;
        nextNodes=new ArrayList<>();
        nextEdges=new ArrayList<>();
    }
    
}
class Edge{
    int weight;
    Node from;
    Node to;

    public Edge(int weight, Node from, Node to) {
        this.weight = weight;
        this.from = from;
        this.to = to;
    }
    
}


//矩阵结构是 weight from to
    static Graph createGraph(int[][] matrix){
        Graph graph = new Graph();
        for (int i = 0; i < matrix.length; i++) {
            int weight = matrix[i][0];
            int from = matrix[i][1];
            int to = matrix[i][2];

            //出入结点之前是否已经有了
            if(!graph.nodes.containsKey(from)){
                graph.nodes.put(from,new Node(from));
            }
            if(!graph.nodes.containsKey(to)){
                graph.nodes.put(to,new Node(to));
            }

            //fromNode
            Node fromNode=graph.nodes.get(from);
            Node toNode=graph.nodes.get(to);
            fromNode.out++;
            fromNode.nextNodes.add(toNode);
            Edge edge = new Edge(weight, fromNode, toNode);
            fromNode.nextEdges.add(edge);

            //toNode
            toNode.in++;

            //asmbely edge
            graph.edges.add(edge);
        }
        return graph;
    }
```

### 图的宽度/深度优先

宽度优先 队列+set  

```
static  void bfs(Node node){
    Queue<Node> queue = new LinkedList<>();
    HashSet<Node> set = new HashSet<>();
    queue.add(node);
    set.add(node);
    System.out.println(node.value);
    while(!queue.isEmpty()){
        Node cur = queue.poll();
        for (Node next : cur.nextNodes) {
            while (!set.contains(next)){
                set.add(next);
                queue.add(next);
                System.out.println(next.value);
            }
        }

    }
}
```

深度优先 栈+set

```
Deque<Node> stack = new LinkedList<Node>();
HashSet<Node> set = new HashSet<>();
stack.add(node);
set.add(node);
System.out.println(node.value);
while(!stack.isEmpty()){
    Node cur =stack.pollLast();
    for (Node next : cur.nextNodes) {
        if (!set.contains(next)){
            stack.add(cur);
            stack.add(next);
            set.add(next);
            System.out.println(cur.value+","+next.value);
            break;
        }
    }

}
```

###  拓扑排序

对一个有向图构造拓扑序列,解决工程能否顺利进行的问题

全部顶点被输出 图中无环;反之,有环

步骤:

1. 初始化: 将所有入度为0的点放入栈中

2. 弹出一个点, 表示删除该顶点,同时刷新其他点(该点的next节点)的入度,为0 入栈

3. 循环2,直到栈中数据为空

   ```
   Deque<Node> stack = new LinkedList<>();
   
   for (Node node : graph.nodes.values()) {
       if(node.in==0){
           stack.add(node);
       }
   }
   
   while (!stack.isEmpty()){
       Node cur = stack.pollLast();
       System.out.println(cur.value);
       for (Node nextNode : cur.nextNodes) {
           nextNode.in--;
           if(nextNode.in==0){
               stack.add(nextNode);
           }
       }
   }
   ```



### 连通图的最小生成树

连通图: 任意两个顶点之间都能够连通，则称此无向图为连通图

满足最小生成树条件:

1. 图是连通图
2. 图中包含N个结点
3. 图中边的数量是N-1

案例一: 获取权重最小的生成树(kruskal)

```
HashSet<Edge> edges = graph.edges;
List<Edge> sortedEdge = edges.stream()
        .sorted(Comparator.comparing(edge -> edge.weight))
        .collect(Collectors.toList());
Set<Node> selectedNode = new HashSet<>();
ArrayList<Edge> minTree = new ArrayList<>();
ArrayList<List<Node>> nodeCollection = new ArrayList<List<Node>>();
for (Edge edge : sortedEdge) {
    if (selectedNode.contains(edge.from) && !selectedNode.contains(edge.to)) {
        Optional<List<Node>> toCollection = nodeCollection.stream().filter(lst -> lst.contains(edge.to)).findFirst();
        if (!toCollection.isPresent()) {
            selectedNode.add(edge.to);
        } else {
            List<Node> nodes = toCollection.get();
            selectedNode.addAll(nodes);
        }
        minTree.add(edge);
    } else if (!selectedNode.contains(edge.from) && selectedNode.contains(edge.to)) {
        Optional<List<Node>> toCollection = nodeCollection.stream().filter(lst -> lst.contains(edge.from)).findFirst();
        if (!toCollection.isPresent()) {
            selectedNode.add(edge.from);
        } else {
            List<Node> nodes = toCollection.get();
            selectedNode.addAll(nodes);
        }
        minTree.add(edge);
    } else if(!selectedNode.contains(edge.from) && !selectedNode.contains(edge.to)){
        if(selectedNode.isEmpty()) {
            selectedNode.add(edge.from);
            selectedNode.add(edge.to);
        }else{
            Optional<List<Node>> fromCollection= nodeCollection.stream().filter(lst->lst.contains(edge.from)).findFirst();
            if(fromCollection.isPresent()){
                fromCollection.get().add(edge.to);
            }else{
                Optional<List<Node>> toCollection= nodeCollection.stream().filter(lst->lst.contains(edge.to)).findFirst();
                if (toCollection.isPresent()){
                    toCollection.get().add(edge.from);
                }else{
                    nodeCollection.add(new ArrayList<Node>(){{
                        add(edge.from);
                        add(edge.to);
                    }});
                }
            }
        }
        minTree.add(edge);
    }
}
    System.out.println(minTree);
    nodeCollection.forEach(System.out::println);
```

**另外可以考虑用并查集合并集合**



### 暴力递归(尝试)

案例一: 汉诺塔

```
    private static void leftToRight(int n) {
        if(n==1){
            System.out.println("move 1 from left to right");
            return;
        }
        leftToMid(n-1);
        System.out.println("move "+ n+" from left to right");
        midToRight(n-1);
    }
```

类似的midToRight/leftToMid/....  为了精简代码,进行进一步优化

```
static void hannuo(int n){
    move(n,"left","right","mid");
}

private static void move(int n,String from,String to,String other) {
    if(n==1){
        System.out.println("move 1 from "+from+" to "+to);
        return;
    }
    move(n-1,from,other,to);
    System.out.println("move "+n+" from "+from+" to "+to);
    move(n-1,other,to,from);
}
```

非递归算法:

1. 将三根柱子按顺序排成品字型, 顺时针摆放,n为偶数,A B C; n为奇数, A C B

2. 把圆盘1从现在的柱子顺时针移动

3. 移动另外的柱子(唯一的选择)

4. 如果不满足条件,返回步骤2

   ```
   public class Solution3 {
       public static void main(String[] args) {
           //init zhu,panList
           int n=11;
           Pie A=new Pie("A");
           Pie B=new Pie("B");
           Pie C=new Pie("C");
           if((n&1)==0) {
               A.nextPie = B;
               B.nextPie=C;
               C.nextPie=A;
           }else{
               A.nextPie=C;
               C.nextPie=B;
               B.nextPie=A;
           }
   
           Pan pan1=new Pan(0,A);
           A.pans.addLast(pan1);
           for (int i = 1; i < n; i++) {
               A.pans.addLast(new Pan(i,A));
           }
   
           ArrayList<Pie> pies = new ArrayList<>(3);
           while (true){
               pies.clear();
               Pie pieOfPan1 = pan1.cur.nextPie;
               if(pieOfPan1!=A){
                   pies.add(A);
               }
               if(pieOfPan1!=B){
                   pies.add(B);
               }
               if(pieOfPan1!=C){
                   pies.add(C);
               }
               pieOfPan1.pans.addFirst(pan1);
               pan1.cur.pans.pollFirst();
               if(pieOfPan1.pans.size()==n){
                   break;
               }
               pan1.cur=pieOfPan1;
   
   
               Deque<Pan> pie1=pies.get(0).pans;
               Deque<Pan> pie2=pies.get(1).pans;
   
               if(pie1.isEmpty()){
                   pie1.addFirst(pie2.pollFirst());
               }else if(pie2.isEmpty()){
                   pie2.addFirst(pie1.pollFirst());
               }else if(pie1.getFirst().val<pie2.getFirst().val){
                   pie2.addFirst(pie1.pollFirst());
               }else{
                   pie1.addFirst(pie2.pollFirst());
               }
   
           }
           System.out.println(C.pans);
   
       }
   
   
   }
   class Pan{
       int val;
       Pie cur; //只对pan1生效
   
       public Pan(int val, Pie cur) {
           this.val = val;
           this.cur = cur;
       }
   
       @Override
       public String toString() {
           return "Pan{" +
                   "val=" + val +
                   '}';
       }
   }
   class Pie{
       String name;
       Deque<Pan> pans=new LinkedList<>();
       Pie nextPie;
   
       public Pie(String name) {
           this.name = name;
       }
   }
   ```



案例二: 用递归实现栈元素的逆序,不用借助其他数据结构

int f(stack)  : 去掉stack底部元素并返回

```
int fn(Deque<Integer> stack){
    int top = stack.pollFirst();
    if(stack.isEmpty()){
        return top;
    }
    int last=fn(stack);
    stack.push(top);
    return last;
}
```

```
void reverse(Deque<Integer> stack){
    if(stack.isEmpty()){
        return;
    }
    int last=fn(stack);
    reverse(stack);
    stack.push(last);
}
```

案例三: 求出字串所有子序列

```
void process(List<String> res,int index,char[] chrs,String path){
    if(index==chrs.length){
        res.add(path);
        return;
    }
    process(res,index+1,chrs,path);
    process(res,index+1,chrs,path+chrs[index]);
}
```

案例四: 求出字串所有子序列,且不出现重复字面值(abc跟案例三一致,aaa则不同)

```
void process2(Set<String> res, int index, char[] chrs, String path){
    if(index==chrs.length){
        res.add(path);
        return;
    }
    process2(res,index+1,chrs,path);
    if(!path.contains(String.valueOf(chrs[index]))) {
        process2(res, index + 1, chrs, path + chrs[index]);
    }
}
```

案例5: 全排列

```
void process3(List<String> res, Set<String> used, String[] strs, String path){
    if(used.size()==strs.length){
        res.add(path);
        return;
    }
    for (String str : strs) {
        if(!used.contains(str)){
            used.add(str);
            process3(res,used,strs,path+str);
            used.remove(str);
        }
    }
}
```

案例6:  1对应A,2对应B 以此类推;11还可以对应K....  比如 111 对应[AAA, AK, KA]   从左到右尝试

```
void process4(List<String> res, int index, char[] chrs,String path){
     if(index==chrs.length){
         res.add(path);
         return;
     }
     if((chrs[index]-'0')>0) {
         process4(res, index + 1, chrs, path + (char)(chrs[index]-'1' + 'A' ));
     }
     if(index<chrs.length-1) {
         int twoVal = (chrs[index]-'0') * 10 + chrs[index + 1]-'0';
         if (twoVal <= 26) {
             process4(res, index + 2, chrs, path + (char)(twoVal + 'A' - 1));
         }
     }
 }
```

案例7: 物品有weights及其values属性, 在不超过bag的前提下如何组合使得value最大 从左到右尝试

```
//curWeight 之前决策的重量
//index当前商品属性
int process5(int bag, int index, int[] weights, int[] values
            ,int curWeight){

    if(curWeight>bag){
        return -1;
    }
    if(index==weights.length){
        return 0;
    }
    //不加入当前物品
    int p1=process5(bag,index+1,weights,values,curWeight);
    //加入当前物品
    int p2=process5(bag,index+1,weights,values,curWeight+weights[index]);
    int tmp=-1;
    if(p2!=-1){
        tmp=values[index]+p2;
    }
    return Math.max(p1,tmp);
}
```

案例8: 有一个不同分数一次排列的数组,AB分别每次取一张卡片且只能取最左或最右.在A,B足够聪明的情况,返回获胜者的分数

```
//先手
int f(int[] arr,int l,int r){
    if(l==r){
        return arr[l];
    }
    int p1=arr[l]+s(arr,l+1,r);
    int p2=arr[r]+s(arr,l,r-1);
    return Math.max(p1,p2);
}

//后手
int s(int[] arr,int l,int r){
        if(l==r) return 0;
        return Math.min(f(arr,l+1,r),f(arr,l,r-1));
 }
    
    int process6(int[] arr,int l,int r){
        return Math.max(f(arr,l,r),s(arr,l,r));
    }
```

案例9:  人要过河,河里有若干只鳄鱼(非常聪明),鳄鱼吃了食物(鱼或人)就会特别虚弱,请问人什么时候过河

​	奇数不过 偶数过

案例10:  ABCDE先后分100个金币(1次性,非长期共谋,他们都足够聪明),必须超过半数的人同意才能通过,否则提案者GG.自己不死的情况下,A怎么分配使得自己获得的金币数量最多(第一个通过的提案即为最终的提案)

​	从E,DE....往上逆推

案例11: N皇后  N*N的棋盘上放N个棋子,要求不再同行,同列,同斜线,请问有多少中摆法

```
//index 当前行的决策
//record[0...index-1] 之前的决策 record[i]=j  第i行选择第j个棋子
static  int nQueen(int n,int index,int[] record){
    if(index==n){
        return 1;
    }
    int res=0;
    for (int col = 0; col < n; col++) {
       if(isValid(index,col,record)){
           record[index]=col;
           res+=nQueen(n,index+1,record);
       }
    }
    return res;
}
static boolean isValid(int index,int col,int[] record){
    for (int i = 0; i < index; i++) {
        int alreadyCol=record[i];
        if(col==alreadyCol
                ||Math.abs(record[i]-col)==Math.abs(index-i)){
            return false;
        }
    }
    return true;
}
```

可以通过二进制(该数表示状态)的方式进一步优化

## 贪心算法

- 最自然智慧的算法
- 用一种局部最功利的标准，总是做出当前看来是最好的选择
- 难点在于证明局部最功利的标准可以得到全局最优解

### 案例

给定一个由字符串数组strs，将所有字串拼接起来，在可能的结果中，返回字典序(string.compareTo)最小的结果

​	反例  [ba,b] bab为不是bab

1. 暴力法 全排列 O(n!)*O(M)

   ```
   /**
    * 
    * @param strs 待组合字符串
    * @param use  tmp,表示当次组合中使用过的元素
    * @param path  当次组合
    * @param all  全部可能的组合
    */
   static void process(String[] strs
               , Set<Integer> use
               , String path
               , List<String> all){
       if(use.size()==strs.length) {
           all.add(path);
           return;
       }
       for (int i = 0; i < strs.length; i++) {
           if(!use.contains(i)){
               use.add(i);
               process(strs,use,path+strs[i],all);
               use.remove(i);
           }
       }
   }
   ```

2. 贪心算法

   * v1    若s1<=s2 则s1在前，反之s2在前

     反例： b<ba  但 bab优于bba

   *  v2   若s1.s2<=s2.s1 则s1在前，否则s2在前

     只要证明该模式具有传递性，即可证明这是最优解

     即 已知对数组中任意字串a,b,c有a.b<=b.a, b.c<=c.b

     则 a.c<=c.a

     可以将x.y结果看作26进制数  =>  x*26^y.len+y

     令m(x)=26^x.len

     1. a.b<=b.a   => a*m(b)+b<=b * m(a)+a
     2. b.c<=c.b   => b*m(c)+c<=c*m(b)+b

     1式 (-b) *c   =>  ac*m(b)<=bc * m(a)+ac-bc

     2式 (-c) a   =>  ab*m(c)<=ac * m(b)+ab-ac

     可得 am(c)+c <=cm(a)+a  即a.c<=c.a



## 动态规划

暴力递归(尝试,经验没方法论)->动态规划

案例一:斐波纳挈

递归

```
if(n<=2){
    return 1;
}
return fibo(n-2)+fibo(n-1);
```

由于f(n-2....1)存在重复计算,进行以下优化

```
int[] fiboNum = new int[n];
fiboNum[0]=1;
fiboNum[1]=1;
for (int i = 2; i < n; i++) {
    fiboNum[i]=fiboNum[i-1]+fiboNum[i-2];
}
return fiboNum[n-1];
```



案例二: 有排成一行的N个位置 记作1-N ,开始机器人在M位置

如果来到1位置,那么下一步只能向右

如果来到N位置,那么下一步只能向左

请问经过K步后正好到P的方法有多少?

递归版

```
int robot(int i,int N,int K,int P){
    if(K==0){
        if(i==P){
            return 1;
        }
        return 0;
    }
    int res=0;
    K--;
    if(i==1){
        res+=robot(i+1,N,K,P);
    }else if(i==N) {
        res += robot(i - 1, N, K, P);
    }else{
        res+=robot(i+1,N,K,P);
        res += robot(i - 1, N, K, P);
    }

    return res;
}
```

或者

```
if(K==0){
    return i==P?1:0;
}


if(i==1) return robot(2,N,K-1,P);
if(i==N) return robot(N-1, N, K-1, P);
return robot(i+1,N,K-1,P)+robot(i - 1, N, K-1, P);
```

其中由于N,P是常熟,实际上robot=f(cur,rest) 该展开存在重复计算 如f(3,4)  存在多个f(3,2)

所以自然想到通过一个缓存将已计算的读取,为未计算的存储

```
int robotWithCache(int i,int N,int K,int P,int[][] dp){
    if(dp[i][K]!=-1){
        return dp[i][K];
    }

    if(K==0){
        dp[i][K]=i==P?1:0;
        return dp[i][K];
    }

    if(i==1) {
       dp[i][K]= robotWithCache(2,N,K-1,P,dp);
       return  dp[i][K];
    }
    if(i==N) {
        dp[i][K]=robotWithCache(N - 1, N, K - 1, P,dp);
        return dp[i][K];
    }
    return robotWithCache(i+1,N,K-1,P,dp)+robotWithCache(i - 1, N, K-1, P,dp);
}
```

**暴力递归的抽象就是动态规划**

**递归改动态规划的前提是存在大量重复计算**

比如N=7 K=5 P=3 M=2

初始化 

K=0  只有CUR=P 为1 其余0

cur=1 依赖左下角

CUR=7 依赖左上角

其余的为左上+左下

| CUR\REST | 0    | 1    | 2    | 3    | 4    | 5    |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0        | x    | x    | x    | x    | x    | x    |
| **1**    | 0    | 0    |      |      |      |      |
| 2        | 0    |      |      |      |      |      |
| 3        | 1    |      |      |      |      |      |
| 4        | 0    |      |      |      |      |      |
| 5        | 0    |      |      |      |      |      |
| 6        | 0    |      |      |      |      |      |
| **7**    | 0    | 0    |      |      |      |      |

从Rest=1->5一次填充表格

| CUR\REST | 0    | 1    | 2    | 3    | 4    | 5    |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0        | x    | x    | x    | x    | x    | x    |
| **1**    | 0    | 0    | 1    | 0    | 3    | 0    |
| 2        | 0    | 1    | 0    | 3    | 0    | 9    |
| 3        | 1    | 0    | 2    | 0    | 6    | 0    |
| 4        | 0    | 1    | 0    | 3    | 0    | 10   |
| 5        | 0    | 0    | 1    | 0    | 4    | 0    |
| 6        | 0    | 0    | 0    | 1    | 0    | 5    |
| **7**    | 0    | 0    | 0    | 0    | 1    | 0    |

其中CUR=M=2 REST=5即为最终结果



案例三:  之前的背包问题

1. 记忆搜索

   ```
   int bagProblemWithCache(int bag, int index, int[] weights, int[] values
           ,int curWeight,int[][] dp){
   
       if(curWeight>bag){
           return -1;
       }
   
       if(dp[index][curWeight]!=-2){
           return dp[index][curWeight];
       }
   
       if(index==weights.length){
           dp[index][curWeight]=0;
           return 0;
       }
       //不加入当前物品
       int p1=bagProblemWithCache(bag,index+1,weights,values,curWeight,dp);
       //加入当前物品
       int p2=bagProblemWithCache(bag,index+1,weights,values,curWeight+weights[index],dp);
       int tmp=-1;
       if(p2!=-1){
           tmp=values[index]+p2;
       }
       dp[index][curWeight]=Math.max(p1,tmp);
       return dp[index][curWeight];
   }
   ```

2. hash表归纳(对暴力递归进行dp[var1] ..... [varn]层面上抽象)

   ```
   int bagProblemInduction(int bag,  int[] weights, int[] values){
       int[][] dp = new int[weights.length + 1][bag + 1];
       //index=N curWeight全为0 自底而上向上推导
       // dp[0][0]就是初始化的状态,即需要求解的问题
       for (int i = weights.length-1; i >=0 ; i--) {
           // >bag区域视为无效区域
           for (int j = 0; j <= bag; j++) {
               //将原本暴力递归的代码 进行归纳 dp[i][j]
               int p1=dp[i+1][j];
               int p2=-1;
               if(j+weights[i]<=bag){
                   p2=values[i]+dp[i+1][j+weights[i]];
               }
               dp[i][j]=Math.max(p1,p2);
           }
       }
       return dp[0][0];
   }
   ```



案例四： 之前数字字母对应的问题（1 对应 A....），在不用输出具体是那几项，只需要可能项数的话，简化

```
int getPokerResult(char[] chrs,int i){
    if(i==chrs.length){
        return 1;
    }
    if(chrs[i]=='0'){
        return 0;
    }

    if(chrs[i]=='1'){
        int res=getPokerResult(chrs,i+1);
        if(i+1<chrs.length){
            res+=getPokerResult(chrs,i+2);
        }
        return res;
    }
    if(chrs[i]=='2'){
        int res=getPokerResult(chrs,i+1);
        if((i+1<chrs.length)
                &&(chrs[i+1]<='0'||chrs[i+1]<='6')){
            res+=getPokerResult(chrs,i+2);
        }
        return res;
    }
    return getPokerResult(chrs,i+1);
}
```

考虑改dp，只有一个变量i，实际就是dp[] (此时完全不用考虑实际场景，直接改)

```
int getPokerResultDp(char[] chrs){
    int[] dp=new int[chrs.length+1];
    dp[chrs.length]=1;
    for (int k = chrs.length-1; k >=0 ; k--) {
        if(chrs[k]=='0'){
            dp[k]=0;
        }else if(chrs[k]=='1'){
            dp[k]=dp[k+1];
            if(k+1<chrs.length){
                dp[k]+=dp[k+2];
            }
        }else if(chrs[k]=='2'){
            dp[k]=dp[k+1];
            if((k+1<chrs.length)
                    &&(chrs[k+1]<='0'||chrs[k+1]<='6')){
                dp[k]+=dp[k+2];
            }
        }else{
            dp[k]+=dp[k+1];
        }
    }
    return dp[0];
}
```



案例五： 已知有一个数组arr 每个元素代表一种面值，每种可以拿任意张，现在要找钱数aim，请问有多少种方法

暴力递归：

```
int getCoin(int[] faceValues,int rest,int i){
    if(rest==0){
        return 1;
    }
    if(i==faceValues.length){
        return 0;
    }
    int res=0;
    while (rest>=0){
        res+=getCoin(faceValues,rest,i+1);
        rest-=faceValues[i];
    }
    return res;
}
```

记忆搜索：

```
int getCoinSearch(int[] faceValues,int rest,int i,int[][] dp){
    if(dp[i][rest]!=-1){
        return dp[i][rest];
    }
    if(rest==0){
        dp[i][0]=1;
        return dp[i][0];
    }
    if(i==faceValues.length){
        dp[i][rest]=0;
        return dp[i][rest];
    }
    int res=0;
    int tmp=rest;
    while (rest>=0){
        res+=getCoin(faceValues,rest,i+1);
        rest-=faceValues[i];
    }
    dp[i][tmp]=res;
    return res;
}
```

递归中没有循环枚举，记忆化搜索时间复杂度等同于经典动态规划

经典动态规划

```
int getCoinDp(int[] faceValues,int rest){
 int[][] dp = new int[faceValues.length + 1][rest + 1];

        for (int j = 0; j < faceValues.length + 1; j++) {
            dp[j][0]=1;
        }
        //dp[faceValues.length][1..rest]默认已经是0

        for (int j = faceValues.length-1; j >= 0; j--) {
            for (int k = 1; k < rest+1; k++) {
                int res=0;
                int tmp=k;
                while (tmp>=0){
                    res+=dp[j+1][tmp];
                    tmp-=faceValues[j];
                }
                dp[j][k]=res;
            }
        }
        return dp[0][rest];
}
```

对于循环枚举，经典dp还可以继续优化以省略枚举

如 dp_3_100=dp_4_100+dp_4_97+.....dp4_4_1

而  dp_3_97=dp_4_97+.....dp4_4_1  

故 dp_3_100= dp_3_97+dp_4_100   可以归纳为 dp_index_rest=dp_index_(rest-faceValues[index]&&this>=0)+dp_index+1_rest

```
if(k-faceValues[j]>=0){
    dp[j][k]=dp[j+1][k]+dp[j][k-faceValues[j]];
}
```



案例N: Dijkstra 算法

求一个图中一个点到其他所有点的最短路径的算法

**（重点）算法要点**

- **result：**已求出 最小路径的顶点
- **notFound：未求出最小路径的顶点，里面的值是 **到起点的距离

```
Map<Node,Integer> result=new HashMap<Node,Integer>(){{
    put(start,0);
}};
Map<Node,Integer> unLinked=new HashMap<Node,Integer>();
Node cur=start;
int curDistance=0;
while (true) {
    for (Edge nextEdge : cur.nextEdges) {
        if(result.containsKey(nextEdge.to)){
            continue;
        }
        if (!unLinked.containsKey(nextEdge.to)) {
            unLinked.put(nextEdge.to, curDistance + nextEdge.weight);
        } else if (curDistance + nextEdge.weight < unLinked.get(nextEdge.to)) {
            unLinked.put(nextEdge.to, curDistance + nextEdge.weight);
        }
    }
    if(cur!=start) {
        unLinked.remove(cur);
    }
    if(unLinked.isEmpty()){
        break;
    }
    Map.Entry<Node, Integer> entry = unLinked.entrySet()
            .stream().min(Comparator.comparingInt(Map.Entry::getValue)).get();
    cur=entry.getKey();
    curDistance=entry.getValue();
    result.put(cur,curDistance);
}
System.out.println(result);
```

# KMP



KMP算法

消除主串指针的回溯

1. 求Next数组

   一位位求模式串需要跳过的步数    最长公共前后缀重合字符的个数

   如 ABACABA 最后一个A是3 而不是1

   新元素填0 set辅助

   mode 1: next[cur-1]==0:

   ​	1..n-1 比对

   mode 2: next[cur-1]>0:

   1. 后缀最新位与前缀之后一位相同 next[j-1]+1

   2. 不同 左半部不同的位置x next[x-1]决定+1 或归0

2. 主串指针一直向前比对 patt j位置不匹配, 则字串前面next[j-1]个字符不用比较

3. 重复2 直到找到匹配或主串走完

```
int[] buildNext(char[] pattern) {
    HashSet<Character> exists = new HashSet<>();
    int[] next = new int[pattern.length];
    for (int i = 0; i < pattern.length; i++) {
        if(!exists.contains(pattern[i])){
            next[i]=0;
            exists.add(pattern[i]);
        }else{
            int prev=next[i-1];
            //前一个元素没有匹配前缀(通用)
            if(prev==0){
                for (int j = 1; j <= i; j++) {
                    int k = j;
                    for (; k <= i; k++) {
                        if(pattern[k]!=pattern[k-j]) break;
                    }
                    if(k==i+1){
                        next[i]=i-j+1;
                    }
                }
            }else{
                //能够继续匹配
                if(pattern[i]==pattern[prev]){
                    next[i]=next[i-1]+1;
                }else{
                    //如果不能继续匹配 则在左半部重新匹配
                    //==0则无匹配 >0则继续匹配
                    int already=next[prev-1];
                    if(already==0) next[i]=0;
                    else next[i]=pattern[i]==pattern[already]?already+1:0;
                }
            }
        }
    }
    return next;
}
```

```
boolean kmp(char[] master,char[] pattern){
    int[] next = buildNext(pattern);
    // i master pointer;j pattern pointer
    int i=0,j=0;
    // i+待比对的模式子串
    while (i+ pattern.length-j<= master.length){
        if(master[i]==pattern[j]){
            i++;
            j++;
            //全部匹配
            if(j== pattern.length) {
                System.out.println("i= "+i+" , j= "+j);
                return true;
            }
        }else{
            j=next[i-1];
        }
    }

    return false;
}
```

# RMQ

给定一个数组,长度N,求区间[l,r],请问区间最大(小)值

方法一: 暴力遍历  O(N^2)

​		且当N,Q足够大,time limit exceeded

方法二: 动态规划 O(N)

记忆化搜索:

```
 int getMaxOfRange(int[] arr,int low,int upper,int[][] dp){
    if(dp[low][upper]!=Integer.MIN_VALUE){
        return dp[low][upper];
    }
    if(low==upper){
         dp[low][upper]=arr[low];
         return dp[low][upper];
     }
     int mid=low+((upper-low)>>1);
    dp[low][upper]=Math.max(getMaxOfRange(arr,low,mid,dp),
            getMaxOfRange(arr,mid+1,upper,dp));
    return dp[low][upper];
}
```

记忆化搜索虽然进行了剪枝,	但递归深度并没有优化,需要很大的调用栈，存储很多参数，内存占用较大

动态规划取消了递归深度

```
int getMaxOfRange2(int[] arr,int low,int upper){
    int[][] dp=new int[upper+1][upper+1];
    // int n=upper-low+1;dp[i][i]=arr[i]
    for (int i = low; i <= upper; i++) {
        dp[i][i]=arr[i];
    }
    //0-1 1-2 2-3 3-4
    //0-2 1-3 2-4
    //0-3 1-4
    //0-4
    for (int round =1; round <=upper-low; round++) {
        int start = low;
        while (start+round<=upper){
            int mid=start+(round>>1);
            dp[start][start+round]=Math.max(dp[start][mid],
                    dp[mid+1][upper] );
            start++;

        }
    }
    return dp[low][upper];
}
```



方法三: RMQ (range max/min query)

假设二维数组 dp(i,j) 表示从i位开始 连续2^j个数中的最小值

求解dp(i,j)  可以分为两部分 
$$
i到i+2^{\left( j-1 \right)}-1
$$

$$
i+2^{\left( j-1 \right)}  到 i+2^j-1
$$

即
$$
dp\left[ i \right] \left[ j \right] =dp\left[ i \right] \left[ j-1 \right] +dp\left[ i+1<<j-1 \right] \left[ j-1 \right]
$$
复杂度分析: N-1+N-3.....N-2^k+1   NLgN-2N+2+lgN   O(NlgN)

java中只有logeN通过换底公式 计算log2N 
$$
\log _2N=\log _eN/\log _e2
$$

```
void rmqInit(int[] arr, int[][] dp ){
    //dp[i][0]=arr[i]
    int n=arr.length;
    for (int i = 0; i < n; i++) {
        dp[i][0]=arr[i];
    }
    //dp[i][j]=....
    for (int j = 1; (1<<j) <= n; j++) {
        for (int i = 0; i+(1<<j)-1 < n; i++) {
            dp[i][j]=Math.max(dp[i][j-1],dp[i+(1<<j-1)][j-1]);
        }
    }
}
```

**查询部分**

​	要查[l,r]中最小值,令
$$
k=\log \left( r-l+1 \right)
$$
  则
$$
RMQ\left[ l,r \right] =\min \left( dp\left[ l,k \right] ,dp\left[ r-1<<k+1 \right] \left[ k \right] \right)
$$
​	当 r-2^k+1<=l+2^k-1  代入上式发现条件不等式恒成立

```
int rmq(int l,int r, int[][] dp ){
    int k=(int)(Math.log(r-l+1)/Math.log(2));
    return Math.max(dp[l][k],dp[r-(1<<k)+1][k]);
}
```



方法四: 线段树

线段树是一种二叉搜索树/平衡树,每个节点都存放[L...R]的信息,其中叶子节点L=R

大致思想是将一个区间平均划分为2个小区间,直到L=R

一个问题满足区间加法,仅当对于区间[L,R]问题的答案可以由[L,M]和[M+1,R]

的答案合并得到

一颗线段树的最大深度

​	一个树的深度  (完全二叉树模式)
$$
\log _2n+1\ \ \ \ \text{其中}n\text{为结点数目}
$$
​	通过归纳得到[1,n]的结点数目为1+2(n-1)  代入上式 
$$
\log _2\left( n-\frac{1}{2} \right) +2\
$$
初始化可以用头结点递归生成整棵树 

```
//[l,r]区间 ,p tree[2*(r-l+1)]位置(从1开始存数)
//arr 原数组
static void build(int l,int r,int p,int[] tree){
    if(l==r){
        tree[p]=arr[l];
    }else{
        int mid=l+((r-l)>>1);
        build(l,mid,p*2,tree);  //build 左子树
        build(mid+1,r,p*2+1,tree);  //build 右子树
        tree[p]=Math.max(tree[p*2],tree[p*2+1]); //求最\大
    }
}
```

建树O(n) 

​	叶子节点n个  非叶子节点 n-1个   共2n+4(n-1) 步常数操作

# 其他

案例一：一个串str “123456” 经过旋转可以分别得到123456、234561、345612.....	 现在有str1,str2，请问它们互为旋转词吗？

常规解法 O(N^2)

```
 boolean isRotate(String str1,String str2){
    if(str1.length()==str2.length()){
        return false;
    }
    int i=0;
    while (i<str1.length()){
        if (str1.charAt(i)==str2.charAt(0)) {
            String str=str1.substring(i)+str1.substring(0,i);  //O(N)
            if(Objects.equals(str,str2)){
                return true;
            }
            return false;
        }
        i++;
    }
    return false;
}
```

优化 将str1序列扩充一倍，如果str1和str2互为旋转词  那么str2就在该新序列中  O(N)

```
boolean isRotate2(String str1,String str2) {
    if (str1.length() != str2.length()) {
        return false;
    }
    str1=str1+str1;
    return str1.contains(str2);
}


```



案例二： 两树T1，T2，求T1中是不是存在T2的结构

暴力递归  O(N*M) N为T1的节点数目 M为T2的节点数目

先序+null（单纯的一种序列无法唯一确定一棵树 需要先中/后中 或 null）



案例三: 一个数组arr, 求第K小的数，要求O(N)

master公式

T [n] = a*T[n/b] + O (N^d)

①当d<log(b,a)时，时间复杂度为O(n^(logb a))

②当d=log(b,a)时，时间复杂度为O((n^d)*logn)

③当d>log(b,a)时，时间复杂度为O(n^d)

1. 随机选择一个数M

2. 通过荷兰旗问题获得partition的两端

3. 判断index在不在两端 不再继续递归

4. 通过概率叠加实现O(N)

   最好的情况M数在数组中间 T(N)=T(N/2)+O(N)  O(N)

   ```
   最坏的情况M每次都在数组一端 O(N^2)
   
   
   ```

```
int process(int[] arr,int l,int r,int index){
        if(l==r){
            return arr[l];
        }
        //随机选一个数应用荷兰旗分区
        int pivot=arr[l+(int)(Math.random()*(r-l+1))];
        int[] range = helanFlag(arr, l, r, pivot);
        if(index>=range[0]&&index<=range[1]){
            return arr[index];
        }else if(index<range[0]){
            return process(arr,l,range[0]-1,index);
        }else{
           return process(arr,range[1]+1,r,index);
        }
    }

    private static int[] helanFlag(int[] arr,int l,int r,int pivot) {
        int i=l,prev=l,last=r;
        while (i<=last){
            if(arr[i]<pivot) {
                if(i==prev){
                    prev++;
                    i++;
                }else {
                    swap(arr, i, prev);
                    prev++;
                }
            } else if(arr[i]>pivot){
                swap(arr,i,last);
                last--;
            }else{
                i++;
            }
        }
//        System.out.println(Arrays.toString(arr));
//        System.out.println(prev+","+last);
        return new int[]{prev,last};
    }


```

1. bfprt(arr,k)

   选M时  先将arr分组,每组5个元素(能计算出收敛O(N)),对每组排序分别求出中位数 m[]   O(N)

   在m[] 递归bfprt(m,N/10) 求出M  T(N/5) 

   用M做荷兰旗分区  O(N)

   对左边或右边继续递归 T(?)

   ​	估算左侧最大规模

   ​	由于m数组是N/5规模,M是中位数  那么m最少有N/10个>=M

   ​	扩大到原数组 则至少有3*N/10>=M

   ​	则规模最大是7*N/10

   ​	同理 右侧最大规模 7*N/10

   ​	T(7*N/10)

    **O(N)**

   ```
   int getM(int[] arr){
       //将数组5个一个分区,取其中每个区的中位数
       int n=arr.length;
       int groupCount=(int) Math.ceil(n / 5.0);
       int[][] partition = new int[groupCount][5];
       int count=0;
       for (int i = 0; i < partition.length; i++) {
           for (int j = 0; j < 5; j++) {
               partition[i][j]=arr[count];
               count++;
               if(count==n) break;
           }
       }
   
       int[] m = new int[groupCount];
       for (int i = 0; i < partition.length; i++) {
           int[] group=partition[i];
           Arrays.sort(group);
           m[i]=group[group.length/2];
       }
      return bfprt(m,0,m.length-1,m.length/2);
   }
   
   
   ```

案例:有一数组,实现奇数放在奇数索引上,偶数放在偶数索引上

三个指针 a指向0 b指向1 c指向末尾 c不动根据元素奇偶和a,b交换并step+2
