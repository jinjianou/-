

[阿里巴巴Java开发者手册官方免费版 - 阿里云 (aliyun.com)](https://developer.aliyun.com/guidebook/java)

# 命名风格

 1. 代码（中的）命名不能以下划线或者美元符号开头或者结尾

 2. 代码命名不能以中文拼音或者中文拼音与英文混合方式

 3. 类名使用UpperCamCamelCase风格，但DO、PO、DTO、VO、BO等除外

    如ProductDTO

 4. 方法名、参数名、变量名统一使用lowerCamelCase，必须遵守驼峰命名

 5. 常量名全部大写，单词间用下划线隔开

 6. 抽象类必须以Abstract或者Base开头，异常类必须以Exception结尾，测试         类以测试的类的名称开头Test结尾

 7. 类型与中括号紧挨相连标示数组

 8. **POJO类中布尔类型变量不要加is前缀**

 9. **包名统一小写，点分隔符有且有一个自然语义单词**

 10. **避免在父子类和不同代码块中采用相同变量名**

 11. 避免不规范的缩写命名

 12. 在对元素命名时用完整单词组合表达其意

 13. **常量和变量命名时，表示类型放在词尾，如：idList、TERMINATED_TREAD_COUNT**

 14. 接口、类、方法、模块使用设计模式，**命名时要体现具体模式**

 15. **接口类中的方法和属性不要加任何修饰符**，并加上有效的javadoc。

 16. 接口和实现类的命名规则：
     1、**对于service和dao类，实现类必须用Impl结尾**；
     2、**如果是形容能力的接口名称，取对应的形容词为接口名** AbstractTranslator实现 Translatable接口

 17. **枚举类名加Enum后缀**，枚举成员名称全大写，单词间用下划线隔开

 18. 各层命名规范：
     A) Service/DAO层命名规约
        1.获取单个对象的方法用get做前缀
        2.**获取多个对象的方法用list做前缀**，如：listObjects
        3.**获取统计值的方法用count做前缀**
        4.插入方法用save/insert做前缀
        5.删除方法用delete/remove做前缀
        6.修改方法用update做前缀
     B）领域模型命名规范
        1.数据对象：xxxDO, xxx为数据库表名
        2.数据传输对象：xxxDTO,xxx为业务模型相关名称
        3.展示对象：xxxVO，xxx一般为网页名称
        4.POJO是对DO、DTO、VO、BO的统称，**禁止xxxPOJO**

# 常量定义



 1. 代码中禁止出现魔法值

    * 避免使用魔法值（未经定义的常量）
    * 原则上0不用于魔法值，0经常作为数组最小下标和变量初始值

 2. **在Long类型中赋值，数值后使用大写L**

 3. **不要在一个常量类中维护所有常量，要根据功能分开维护**

 4. 常量的复用层次：
    1.跨应用：放在二方库中，通常在constant目录下
    2.应用内：放在一方库中，通常在constant目录下
    3.子工程内：放在当前子工程constant目录下
    4.包内共享常量：当前包下单独的constant目录下
    5.类内共享常量：直接在类内部private static final定义

    **常量类需要放在constant文件夹下**

 5. 如果变量值只在固定的范围内变化，用enum类型定义

    对于固定并且编译时对象，如 Status、Type 等，应该采用 enum 而非自定义常量实现，enum 的好处是类型更清楚，不会再编译时混淆

# 代码格式

# Mysql

## 建表规约

1. 【强制】表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint （ 1 表示是，0 表示否）。 说明：任何字段如果为非负数，必须是 unsigned。 正例：表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。

2. 【强制】**表名、字段名必须使用小写字母或数字**，禁止出现数字开头，禁止两个下划线中间只 出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。 说明：**MySQL 在 Windows 下不区分大小写，但在 Linux 下默认是区分大小写**。**因此，数据库 名、表名、字段名，都不允许出现任何大写字母，避免节外生枝**。

    正例：getter_admin，task_config，level3_name 

   反例：GetterAdmin，taskConfig，level_3_name

3.  【强制】表名不使用复数名词。 说明：表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于 DO 类名也是单数 形式，符合表达习惯。

4.  【强制】禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。

5. 【强制】**主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名则为 idx_字段名**。 

   说明：pk_ 即 primary key；uk_ 即 unique key；idx_ 即 index 的简称。

6. **【强制】小数类型为 decimal，禁止使用 float 和 double。**

    说明：float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不 正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。

7. 【强制】如果存储的字符串长度几乎相等，使用 char 定长字符串类型。

   理解: char预先分配存储空间,存入时无需判断分配的存储空间长度,提高性能

8.  【强制】varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长 度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索 引效率。

   **varchar(5000) 代表5000个字符,包括汉字**

9. 【强制】表必备三字段：id, gmt_create, gmt_modified。

    说明：其中 id 必为主键，类型为 unsigned bigint、单表时自增、步长为 1。gmt_create,  gmt_modified 的类型均为 date_time 类型，前者现在时表示主动创建，后者过去分词表示被 动更新。

   id+create_time+update_time

10. 【推荐】表的命名最好是加上“**业务名称_表的作用**”。 正例：alipay_task / force_project / trade_config

11. 【推荐】库名与应用名称尽量一致。

12. 【推荐】如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。

13. 【推荐】字段允许适当冗余，以提高查询性能(避免关联查询)，但必须考虑数据一致。冗余字段应遵循：

     1）不是频繁修改的字段(考虑数据一致)。

     2）不是 varchar 超长字段，更不能是 text 字段(避免影响其它字段索引效率)。 

    正例：商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存 储类目名称，避免关联查询。

14.  【推荐】单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。 

    说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。

15.  【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检 索速度。

16.  正例：如下表，其中无符号值可以避免误存负数，且扩大了表示范围。 对象 年龄区间 类型 表示范围 

    人 150 岁之内 unsigned tinyint 无符号值：0 到 255 

    龟 数百岁 unsigned smallint 无符号值：0 到 65535 

    恐龙化石 数千万年 unsigned int 无符号值：0 到约 42.9 亿 

    太阳 约 50 亿年 unsigned bigint 无符号值：0 到约 10 的 19 次方



## 索引规约

1. 【强制】**业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引**。 

   说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明 显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必 然有脏数据产生。

2. 【强制】**超过三个表禁止 join**。需要 join 的字段，数据类型必须绝对一致；多表关联查询时， 保证被关联的字段需要有索引。 说明：即使双表 join 也要注意表索引、SQL 性能。

3. 【强制】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据 实际文本区分度决定索引长度即可。 说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引度,区分度会高达 90%以上，可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度 来确定。

   0.75左右即可

4. 【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。

    说明：索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索 引。

5. 【推荐】如果有 order by 的场景，请注意利用索引的**有序性**。order by 最后的字段是组合 索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能。 

   正例：where a=? and b=? order by c; 索引：a_b_c 

   反例：**索引中有范围(包含 in)查找，那么索引有序性无法利用**，如：WHERE a>10 ORDER BY b; 索引 a_b 无法排序。

   

   在mysql中order by 有两种排序实现方式:

   1. 利用有序索引获取有序数据  Using index 

      [where+]order by满足索引最左前缀定义并order顺序一致

   2. 文件排序 Using filesort

      在MySQL Query Optimizer 所给出的执行计划 (通过 EXPLAIN 命令查看)中被称为文件排序（filesort）. 文件排序是通过相应的排序算法,将取得的数据在内存中进行排序: MySQL需要将数据在内存中进行排序，所使用的内存区域也就是我们通过**sort_buffer_size 系统变量所设置的排序区**。. 这个排序区是每个Thread 独享的，所以说可能在同一时刻在MySQL 中可能存在多个 sort buffer 内存区域。

      双路排序：是首先根据相应的条件取出相应的排序字段和可以直接定位行数据的行指针信息，然后在sort buffer 中进行排序。排序后再吧查询字段依照行指针取出，共执行两次磁盘io。

      单路排序：是一次性取出满足条件行的所有字段，然后在sort buffer中进行排序。 执行一次磁盘io。

6. 【推荐】利用覆盖索引来进行查询操作，避免回表。

    说明：如果一本书需要知道第 11 章是什么标题，会翻开第 11 章对应的那一页吗？目录浏览 一下就好，这个目录就是起到覆盖索引的作用。

    正例：能够建立索引的种类：主键索引、唯一索引(多个,可null)、普通索引，而覆盖索引是一种查询的一种 效果，用 explain 的结果，extra 列会出现：using index。

7. 【推荐】利用延迟关联或者子查询优化超多分页场景。

   说明：MySQL 并不是跳过 offset 行，而是**取 offset+N 行，然后返回放弃前 offset-1 行(offset start with 1,表示第offset行开始,可省略)，返回 N 行**，那当 offset 特别大的时候，效率就非常的低下(扫描行数过多,大量的回表I/O查询)，要么控制返回的总页数，要么对超过 特定阈值的页数进行 SQL 改写。 

   正例：先快速定位需要获取的 id 段(覆盖索引)，然后再关联SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id

   **主要针对非主键索引**

9. 【推荐】SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，如果可以是 consts 最好。 

   说明： 1）consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。

    2）ref 指的是使用普通的索引（normal index）。

    3）range 对索引进行范围检索。 

   反例：explain 表的结果，type=index，索引物理文件全扫描，速度非常慢，这个 index 级 别比较 range 还低，与全表扫描是小巫见大巫。

   index: full index scan,index与all的区别是index只遍历索引树,all从硬盘读.且索引文件通常比数据文件小(不考虑回表)

10. 【推荐】建组合索引的时候，区分度最高的在最左边。

     正例：如果 where a=? and b=? ，a 列的几乎接近于唯一值，那么只需要单建 idx_a 索引即 可。 

    说明：存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如：where a>?  and b=? 那么即使 a 的区分度更高，也必须把 b 放在索引的最前列

11. 【推荐】防止因字段类型不同造成的隐式转换，导致索引失效

    - 如果一个或两个参数均为NULL，则比较结果为NULL；但是 <=> [相等比较运算符](https://www.zhihu.com/search?q=%E7%9B%B8%E7%AD%89%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A428772173%7D)除外，对于ANY <=> NULL，结果为null，无需转换。

    - 如果比较操作中的两个参数都是[字符串](https://www.zhihu.com/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A428772173%7D)，则将它们作为字符串进行比较。

    - 如果两个参数都是整数，则将它们作为整数进行比较。

    - 如果[十六进制](https://www.zhihu.com/search?q=%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A428772173%7D)不是和数字作比较，它会被视作是[二进制](https://www.zhihu.com/search?q=%E4%BA%8C%E8%BF%9B%E5%88%B6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A428772173%7D)字符串。

    - 如果参数之一是TIMESTAMP或DATETIME列，而另一个参数是常量，则在执行比较之前，该常量将转换为[时间戳](https://www.zhihu.com/search?q=%E6%97%B6%E9%97%B4%E6%88%B3&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A428772173%7D)，但对于IN() 内的参数不执行此操作。为了安全起见，在进行比较时，请始终使用**完整的时间、日期或时间字符串,整数(时间戳)**。例如，要在日期和时间参数上使用 BETWEEN 函数时，最好使用 CAST() 函数把参数显示转换成所需的数据类型。

      CAST(expression AS TYPE);

      目标类型可以是以下类型之一：`BINARY`，`CHAR`，`DATE`，`DATETIME`，`TIME`，`DECIMAL`，`SIGNED`，`UNSIGNED` 

    - 一个或多个表中的[单行子查询](https://www.zhihu.com/search?q=%E5%8D%95%E8%A1%8C%E5%AD%90%E6%9F%A5%E8%AF%A2&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A428772173%7D)不视为常量。例如，如果子查询返回的整数要与DATETIME值进行比较，则比较将作为两个整数完成，子查询返回的整数不转换为时间值。参见上一条，这种情况下请使用CAST()将子查询的结果整数值转换为DATETIME。

    - 如果参数之一是十进制值，则比较取决于另一个参数。如果另一个参数是[十进制](https://www.zhihu.com/search?q=%E5%8D%81%E8%BF%9B%E5%88%B6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A428772173%7D)或整数值，则将参数作为十进制值进行比较；如果另一个参数是浮点值，则将参数作为浮点值进行比较。

    - **在所有其他情况下，将参数作为浮点数（实数）进行比较**。例如，将字符串和数字操作数进行比较，将其作为浮点数的比较。

      

      所以索引列是字符串时，如果传入的条件参数是整数 

      MySQL在执行我们的查询SQL时，会 **CAST 函数**把每一行主键列的值转换成浮点数，然后再与条件参数做比较。而 InnoDB 存储引擎中，在索引列上使用函数会导致索引失效，所以最后导致了全表扫描。 

      索引列参与了计算 不会使用索引 比如 left(sname,1),cast   子查询返回值使用函数则不会使索引失效

12. 【参考】创建索引时避免有如下极端误解：

     1）宁滥勿缺。误认为一个查询就需要建一个索引

     2）宁缺勿滥。误认为索引会消耗空间、严重拖慢更新和新增速度

     3）抵制惟一索引。误认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。



## SQL语句

1. 不要使用 count(列名)或 count(常量)来替代 count(*)，count(*)是 SQL92 定义的 标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关

   innodb 性能: count(*)=count(1) >count(列名)

   count(1)  统计某个表中1永远不为null的记录数,也就是统计表中记录数.推荐count(*),count(列名)

2.  【强制】count(distinct col) 计算该列除 NULL 之外的不重复行数，注意 count(distinct col1, col2) 如果其中一列全为 NULL，那么即使另一列有不同的值，也返回为 0。

3. 【强制】当某一列的值全是 NULL 时，count(col)的返回结果为 0，但 sum(col)的返回结果为 NULL，因此使用 sum()时需注意 NPE(Null Pointer Exception) 问题。 

   正例：可以使用如下方式来避免 sum 的 NPE 问题：SELECT IF(ISNULL(SUM(g)),0,SUM(g)) FROM table;

4.  【强制】使用 ISNULL()来判断是否为 NULL 值。注意：NULL 与任何值的直接比较都为 NULL。 

   说明： 1） NULL<>NULL 的返回结果是 NULL，而不是 false。 2） NULL=NULL 的返回结果是 NULL，而不是 true。

    3） NULL<>1 的返回结果是 NULL，而不是 true。

5. 【强制】在代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句。

6.  【强制】不得使用外键与级联，一切外键概念必须在应用层解决。 

   说明：（概念解释）学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。 如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，则为级联更新。 外键与级联更新适用于单机低并发，**不适合分布式、高并发集群**；级联更新是强阻塞，存在数 据库更新风暴的风险；外键影响数据库的插入速度。

7. 【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。

8. 【强制】**数据订正时，删除和修改记录时，要先 select，避免出现误删除，确认无误才能执 行更新语句。**

9. 【推荐】in 操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控 制在 1000 个之内。

10.  【参考】如果有全球化需要，所有的字符存储与表示，均以 utf-8 编码，注意字符统计函数 的区别。 
    说明： SELECT LENGTH("轻松工作")； 返回为 12 

    SELECT CHARACTER_LENGTH("轻松工作")； 返回为 4 

    如果要使用表情，那么使用 utfmb4 来进行存储，注意它与 utf-8 编码的区别。

11. 【参考】**TRUNCATE TABLE** 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE 无事务且不触发 trigger，有可能造成事故，故**不建议在开发代码中使用**此语句。 

    说明：TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。



## ORM映射

1. 【强制】在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。 

   说明：1）增加查询分析器解析成本。

   2）增减字段容易与 resultMap 配置不一致。

2. 【强制】POJO 类的布尔属性不能加 is，而数据库字段必须加 is_，要求在 resultMap 中进行 字段与属性之间的映射。

    说明：参见定义 POJO 类以及数据库字段定义规定，在中增加映射，是必须的。 在 MyBatis Generator 生成的代码中，需要进行对应的修改。

3. 【强制】不要用 resultClass 当返回参数，即使所有类属性名与数据库字段一一对应，也需 要定义；反过来，每一个表也必然有一个与之对应。 说明：配置映射关系，使字段与 DO 类解耦，方便维护。

4.  【强制】sql.xml 配置参数使用：#{}，#param# 不要使用${} 此种方式容易出现 SQL 注入。

   #xxx# ibatis的写法

5.   【强制】iBATIS 自带的 queryForList(String statementName,int start,int size)不推 荐使用。

    说明：其实现方式是在数据库取到statementName对应的SQL语句的所有记录，再通过subList 取 start,size 的子集合。 

   正例：Map map = new HashMap();  map.put("start", start);  map.put("size", size); 

6. 【强制】**不允许直接拿 HashMap 与 Hashtable 作为查询结果集的输出**。 说明：resultClass=”Hashtable”，会置入字段名和属性值，但是值的类型不可控。

7.   【强制】**更新数据表记录时，必须同时更新记录对应的 gmt_modified 字段值为当前时间**。

8.    【推荐】不要写一个大而全的数据更新接口，传入为 POJO 类，不管是不是自己的目标更新字 段，都进行 update table set c1=value1,c2=value2,c3=value3; 这是不对的。执行 SQL 时，不要更新无改动的字段，一是易出错；二是效率低；三是增加 binlog 存储。

9.  【参考】@Transactional 事务不要滥用。事务会影响数据库的 QPS，另外使用事务的地方需 要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。

10.  【参考】<isEqual>中的 compareValue 是与属性值对比的常量，一般是数字，<isNotEmpty>表示相等时带 上此条件；<isNotNull>表示不为空且不为 null 时执行；表示不为 null 值时 执行。
    ibatis的标签而不是Mybatis的 

    **<isEqual** property="status" compareValue="1" prepend=","**>** 

    其他类似 但注意不在where标签内