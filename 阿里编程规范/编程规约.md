

[阿里巴巴Java开发者手册官方免费版 - 阿里云 (aliyun.com)](https://developer.aliyun.com/guidebook/java)

# 命名风格

 1. 代码（中的）命名不能以下划线或者美元符号开头或者结尾

 2. 代码命名不能以中文拼音或者中文拼音与英文混合方式

 3. 类名使用UpperCamCamelCase风格，但DO、PO、DTO、VO、BO等除外

    如ProductDTO

 4. 方法名、参数名、变量名统一使用lowerCamelCase，必须遵守驼峰命名

 5. 常量名全部大写，单词间用下划线隔开

 6. 抽象类必须以Abstract或者Base开头，异常类必须以Exception结尾，测试         类以测试的类的名称开头Test结尾

 7. 类型与中括号紧挨相连标示数组

 8. **POJO类中布尔类型变量不要加is前缀**

 9. **包名统一小写，点分隔符有且有一个自然语义单词**

 10. **避免在父子类和不同代码块中采用相同变量名**

 11. 避免不规范的缩写命名

 12. 在对元素命名时用完整单词组合表达其意

 13. **常量和变量命名时，表示类型放在词尾，如：idList、TERMINATED_TREAD_COUNT**

 14. 接口、类、方法、模块使用设计模式，**命名时要体现具体模式**

 15. **接口类中的方法和属性不要加任何修饰符**，并加上有效的javadoc。

 16. 接口和实现类的命名规则：
     1、**对于service和dao类，实现类必须用Impl结尾**；
     2、**如果是形容能力的接口名称，取对应的形容词为接口名** AbstractTranslator实现 Translatable接口

 17. **枚举类名加Enum后缀**，枚举成员名称全大写，单词间用下划线隔开

 18. 各层命名规范：
     A) Service/DAO层命名规约
        1.获取单个对象的方法用get做前缀
        2.**获取多个对象的方法用list做前缀**，如：listObjects
        3.**获取统计值的方法用count做前缀**
        4.插入方法用save/insert做前缀
        5.删除方法用delete/remove做前缀
        6.修改方法用update做前缀
     B）领域模型命名规范
        1.数据对象：xxxDO, xxx为数据库表名
        2.数据传输对象：xxxDTO,xxx为业务模型相关名称
        3.展示对象：xxxVO，xxx一般为网页名称
        4.POJO是对DO、DTO、VO、BO的统称，**禁止xxxPOJO**

# 常量定义



 1. 代码中禁止出现魔法值

    * 避免使用魔法值（未经定义的常量）
    * 原则上0不用于魔法值，0经常作为数组最小下标和变量初始值

 2. **在Long类型中赋值，数值后使用大写L**

 3. **不要在一个常量类中维护所有常量，要根据功能分开维护**

 4. 常量的复用层次：
    1.跨应用：放在二方库中，通常在constant目录下
    2.应用内：放在一方库中，通常在constant目录下
    3.子工程内：放在当前子工程constant目录下
    4.包内共享常量：当前包下单独的constant目录下
    5.类内共享常量：直接在类内部private static final定义

    **常量类需要放在constant文件夹下**

 5. 如果变量值只在固定的范围内变化，用enum类型定义

    对于固定并且编译时对象，如 Status、Type 等，应该采用 enum 而非自定义常量实现，enum 的好处是类型更清楚，不会再编译时混淆

# 代码格式

# Mysql

## 建表规约

1. 【强制】表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint （ 1 表示是，0 表示否）。 说明：任何字段如果为非负数，必须是 unsigned。 正例：表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。

2. 【强制】**表名、字段名必须使用小写字母或数字**，禁止出现数字开头，禁止两个下划线中间只 出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。 说明：**MySQL 在 Windows 下不区分大小写，但在 Linux 下默认是区分大小写**。**因此，数据库 名、表名、字段名，都不允许出现任何大写字母，避免节外生枝**。

    正例：getter_admin，task_config，level3_name 

   反例：GetterAdmin，taskConfig，level_3_name

3.  【强制】表名不使用复数名词。 说明：表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于 DO 类名也是单数 形式，符合表达习惯。

4.  【强制】禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。

5. 【强制】**主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名则为 idx_字段名**。 

   说明：pk_ 即 primary key；uk_ 即 unique key；idx_ 即 index 的简称。

6. **【强制】小数类型为 decimal，禁止使用 float 和 double。**

    说明：float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不 正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。

7. 【强制】如果存储的字符串长度几乎相等，使用 char 定长字符串类型。

   理解: char预先分配存储空间,存入时无需判断分配的存储空间长度,提高性能

8.  【强制】varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长 度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索 引效率。

   **varchar(5000) 代表5000个字符,包括汉字**

9. 【强制】表必备三字段：id, gmt_create, gmt_modified。

    说明：其中 id 必为主键，类型为 unsigned bigint、单表时自增、步长为 1。gmt_create,  gmt_modified 的类型均为 date_time 类型，前者现在时表示主动创建，后者过去分词表示被 动更新。

   id+create_time+update_time

10. 【推荐】表的命名最好是加上“**业务名称_表的作用**”。 正例：alipay_task / force_project / trade_config

11. 【推荐】库名与应用名称尽量一致。

12. 【推荐】如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。

13. 【推荐】字段允许适当冗余，以提高查询性能(避免关联查询)，但必须考虑数据一致。冗余字段应遵循：

     1）不是频繁修改的字段(考虑数据一致)。

     2）不是 varchar 超长字段，更不能是 text 字段(避免影响其它字段索引效率)。 

    正例：商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存 储类目名称，避免关联查询。

14.  【推荐】单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。 

    说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。

15.  【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检 索速度。

16.  正例：如下表，其中无符号值可以避免误存负数，且扩大了表示范围。 对象 年龄区间 类型 表示范围 

    人 150 岁之内 unsigned tinyint 无符号值：0 到 255 

    龟 数百岁 unsigned smallint 无符号值：0 到 65535 

    恐龙化石 数千万年 unsigned int 无符号值：0 到约 42.9 亿 

    太阳 约 50 亿年 unsigned bigint 无符号值：0 到约 10 的 19 次方



## 索引规约

1. 【强制】**业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引**。 

   说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明 显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必 然有脏数据产生。

2. 【强制】**超过三个表禁止 join**。需要 join 的字段，数据类型必须绝对一致；多表关联查询时， 保证被关联的字段需要有索引。 说明：即使双表 join 也要注意表索引、SQL 性能。

3. 【强制】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据 实际文本区分度决定索引长度即可。 说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引度,区分度会高达 90%以上，可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度 来确定。

   0.75左右即可

4. 【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。

    说明：索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索 引。

5. 【推荐】如果有 order by 的场景，请注意利用索引的**有序性**。order by 最后的字段是组合 索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能。 

   正例：where a=? and b=? order by c; 索引：a_b_c 

   反例：**索引中有范围(包含 in)查找，那么索引有序性无法利用**，如：WHERE a>10 ORDER BY b; 索引 a_b 无法排序。

   

   在mysql中order by 有两种排序实现方式:

   1. 利用有序索引获取有序数据  Using index 

      [where+]order by满足索引最左前缀定义并order顺序一致

   2. 文件排序 Using filesort

      在MySQL Query Optimizer 所给出的执行计划 (通过 EXPLAIN 命令查看)中被称为文件排序（filesort）. 文件排序是通过相应的排序算法,将取得的数据在内存中进行排序: MySQL需要将数据在内存中进行排序，所使用的内存区域也就是我们通过**sort_buffer_size 系统变量所设置的排序区**。. 这个排序区是每个Thread 独享的，所以说可能在同一时刻在MySQL 中可能存在多个 sort buffer 内存区域。

      双路排序：是首先根据相应的条件取出相应的排序字段和可以直接定位行数据的行指针信息，然后在sort buffer 中进行排序。排序后再吧查询字段依照行指针取出，共执行两次磁盘io。

      单路排序：是一次性取出满足条件行的所有字段，然后在sort buffer中进行排序。 执行一次磁盘io。

6. 【推荐】利用覆盖索引来进行查询操作，避免回表。

    说明：如果一本书需要知道第 11 章是什么标题，会翻开第 11 章对应的那一页吗？目录浏览 一下就好，这个目录就是起到覆盖索引的作用。

    正例：能够建立索引的种类：主键索引、唯一索引(多个,可null)、普通索引，而覆盖索引是一种查询的一种 效果，用 explain 的结果，extra 列会出现：using index。

7. 【推荐】利用延迟关联或者子查询优化超多分页场景。

   说明：MySQL 并不是跳过 offset 行，而是**取 offset+N 行，然后返回放弃前 offset 行，返回 N 行**，那当 offset 特别大的时候，效率就非常的低下(扫描行数过多,大量的回表I/O查询)，要么控制返回的总页数，要么对超过 特定阈值的页数进行 SQL 改写。 

   正例：先快速定位需要获取的 id 段(覆盖索引)，然后再关联SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id

8. 【推荐】SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，如果可以是 consts 最好。

    说明： 1）consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。

    2）ref 指的是使用普通的索引（normal index）。

    3）range 对索引进行范围检索。

9. 【推荐】SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，如果可以是 consts 最好。 

   说明： 1）consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。

    2）ref 指的是使用普通的索引（normal index）。

    3）range 对索引进行范围检索。 

   反例：explain 表的结果，type=index，索引物理文件全扫描，速度非常慢，这个 index 级 别比较 range 还低，与全表扫描是小巫见大巫。

   index: full index scan,index与all的区别是index只遍历索引树,all从硬盘读.且索引文件通常比数据文件小(不考虑回表)

