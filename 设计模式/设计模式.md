# 初识

1.设计模式是前人对代码开发经验的总结,是解决特定问题的一系列套路.不是语法规定.

2.gof  gang of four 一般有23种 

3.本质是面向对象设计原则的实际运用

4.分类:创建者模式  5/结构型 7/行为型 11 

* oop七大原则

  **开闭原则:**对扩展开放,对修改关闭

  **里氏替换原则**:继承必须保证超类拥有的性质在子类种依然成立

  **依赖倒置原则**: 要面向接口编程,而不是面向实现编程

  **单一职责原则**:控制类的粒度 低耦合,高内聚

  **接口隔离原则**:控制接口的粒度,通过组合的方式或则需要的

  迪米特法则:只与你的直接朋友交谈,不跟'陌生人'讲话

  **合成复用原则:优先考虑组合/聚合 其次才是继承**

  ​	**用对象的职责而不是结构来考虑问题**





# 装饰器模式P65

动态地给一个对象添加一些额外的职责	

![image-20220822164412278](assets/image-20220822164412278.png)

如果只有一个ConcreteComponent而没有抽象的Component,那么Decorator可以是ConcreteComponent的一个子类

同理,如果只有一个ConcreteDecorator,那么也没有必要建立一个单独的 Decorator类,而可以吧Decorator和ConcreteDecorator的责任合并到一个类



Component

```
public abstract class Component {
   abstract void operation();
}
```



ConcreteComponent

```
public class ConcreteComponent extends Component{
    @Override
    void operation() {
        System.out.println("ConcreteComponent operation");
    }
}
```

Decorator

```
public abstract class Decorator extends Component {
     protected Component component;
     public Decorator(Component component){
        this.component=component;
     }

    @Override
    void operation() {
        component.operation();
    }
}
```

ConcereteDecoratorA

```
public class ConcereteDecoratorA extends Decorator{
    private String addState;

    public ConcereteDecoratorA(Component component) {
        super(component);
        System.out.println("具体装饰对象Ａ的操作");
    }

    @Override
    void operation() {
        component.operation();
    }
}
```

ConcereteDecoratorB & main

```
public class ConcereteDecoratorB extends Decorator{
    public ConcereteDecoratorB(Component component) {
        super(component);
    }

    @Override
    void operation() {
        super.operation();
        addBehavior();
        System.out.println("具体装饰对象Ｂ的操作");
    }

    private void addBehavior(){
        System.out.println("add additional functionality");
    }

    public static void main(String[] args) {
        Component component = new ConcreteComponent();
        ConcereteDecoratorA d1 = new ConcereteDecoratorA(component);
        ConcereteDecoratorB d2 = new ConcereteDecoratorB(component);
        d1.operation();
        System.out.println("=======");
        d2.operation();
    }
}
```


# 适配器模式

**将一个类的接口转化成客户需要的另外一个接口**。Adapter模式使得原本由于不兼容而不能工作的类一起工作。

GOF适配器模式有两种，类适配模式和**对象适配模式**，其中类适配模式通过多继承模式对一个接口与另一个接口进行匹配

![1661578206204](assets/1661578206204.png)



```
public class Target {
    public void request(){
        System.out.println("request");
    }
}
```

```
public class Adaptee {
    public void specificRequest(){
        System.out.println("SpecificRequest");
    }
}
```

```
public class Adapter extends Target {
    //private
    private Adaptee adaptee=new Adaptee();

    @Override
    public void request() {
        adaptee.specificRequest();
    }
}
```

```
public class Client {
    public static void main(String[] args) {
        Target target=new Adapter();
        target.request();
    }
}
```



**在双方都不容易做出修改的时候使用适配器模式**



# 桥接模式P237

架构的演进

1. 有N品牌手机游戏，M品牌手机游戏

   ![1661581629970](assets/1661581629970.png)

2. 此时两个又新增通讯录软件

   ![1661581687729](assets/1661581687729.png)

3. 在增加mp3功能 在手机品牌下新增子类

4. 如果再增加一个手机品牌S,尝试另一种结构  当手机品牌和软件增多，类和类的继承层次规模就很大

   ![1661581816574](assets/1661581816574.png)

   5. **用对象的职责而不是结构来考虑问题** 优先聚合/组合而非继承  也就是桥接模式

      ![1661581947143](assets/1661581947143.png)





桥接模式（bridge）:将抽象部分与其实现部分分离，使他们都可以独立变化

![1661582376379](assets/1661582376379.png)

```
public abstract class Implementor {
    public abstract void operationImpl();
}
```

```
public class ConcreteImplementorA extends Implementor{
    @Override
    public void operationImpl() {
        System.out.println("ConcreteImplementorA");
    }
}
```

```
//可以不是抽象类
public  class Abstraction {
    protected Implementor implementor;

    public void setImplementor(Implementor implementor){
        this.implementor=implementor;
    }

    public  void operation(){
        implementor.operationImpl();
    }
}
```

```
public class RefinedAbstraction extends Abstraction{
    @Override
    public void operation() {
        implementor.operationImpl();
    }

    public static void main(String[] args) {
        Abstraction ra = new RefinedAbstraction();
        ra.setImplementor(new ConcreteImplementorA());
        ra.operation();
    }
}
```



**总结：实现系统可能有多角度分类，每一个分类都可能变化，那么就把多角度分离出来让他们独立变化，减少他们之间的耦合**

